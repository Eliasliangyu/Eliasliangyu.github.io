<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://eliasliangyu.github.io/"/>
  <updated>2019-07-19T09:46:19.363Z</updated>
  <id>https://eliasliangyu.github.io/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HeartDisease Risk Prediction System简要说明</title>
    <link href="https://eliasliangyu.github.io/2019/07/18/HeartDisease-Risk-Prediction-System%E7%AE%80%E8%A6%81%E8%AF%B4%E6%98%8E/"/>
    <id>https://eliasliangyu.github.io/2019/07/18/HeartDisease-Risk-Prediction-System简要说明/</id>
    <published>2019-07-18T14:59:08.000Z</published>
    <updated>2019-07-19T09:46:19.363Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这个项目测试并筛选了UCI心脏病数据集上的数据给出的的各个属性，预测这些属性诱发心脏病的概率。我的目标是从用户提供的数据来预测是否会以最大的准确度对心脏病预测以及进行治疗的可能性，并找出哪些属性对诱发心脏病的影响最大。</p><p>该数据集包含4个关于心脏病诊断的数据库。所有属性都是数字值。数据由UCI提供，来自以下四个地点：</p><ul><li>克利夫兰诊所基金会</li><li>布达佩斯匈牙利心脏病研究所</li><li>VA医疗中心，长滩，加利福尼亚州</li><li>瑞士苏黎世大学医院</li></ul><h2>属性信息：</h2>1.age：年龄<p>2.sex：（1 =男性; 0 =女性）</p><p>3.cp：胸痛型</p><ul><li>Value1：典型心绞痛</li><li>Value2：非典型心绞痛</li><li>Value3：非心绞痛</li><li>Value4：无症状</li></ul>4.trestbps：静息血压<p>5.CHOL：cholestoral</p><p>6.fbs :(空腹血糖&gt; 120 mg / dl）（1 =真; 0 =假）</p><p>7.restecg：</p><ul><li>Value0：正常</li><li>Value1：具有ST-T波异常</li><li>Value2：显示可能或确定的左心室肥大</li></ul><p>8.thalach：达到最大心率</p><p>9.exang：运动诱发心绞痛（1 =是; 0 =否）</p><p>10.oldpeak：运动引起的ST抑郁相对于休息</p><p>11.slope：峰值运动ST段的斜率</p><ul><li>Value1：uploping</li><li>Value2：持平</li><li>Value3：下滑</li></ul><p>12.ca：由蓬松染色的主要容器（0-3）的数量</p><p>13.thal：</p><ul><li>3 =正常</li><li>6 =固定缺陷</li><li>7 =可逆缺陷</li></ul><p>14.类别：心脏病的诊断[0-4]（预测属性）<br><b>这里1-4表示诊断为True，0表示没有心脏病</b></p><h2>基于ExtraTreeClassifier的属性重要性</h2>![](1.png)<h2>依赖库</h2><ul><li>Flask Server</li><li>Keras</li><li>Pandas</li><li>Numpy</li><li>Sklearn</li></ul><h2>Testing and Training</h2>![](2.png)<p>使用2层神经N / W我们得到准确度：96％和精度：93％</p><h2>前端和结果</h2>![](3.png)<p></p>![](4.png)<p></p><h2>欠缺</h2>数据量少；<p></p>算法较弱；<p></p>功能太少；<p></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="project" scheme="https://eliasliangyu.github.io/tags/project/"/>
    
  </entry>
  
  <entry>
    <title>V2EX社区论坛推荐</title>
    <link href="https://eliasliangyu.github.io/2019/07/12/V2EX%E7%A4%BE%E5%8C%BA%E8%AE%BA%E5%9D%9B%E6%8E%A8%E8%8D%90/"/>
    <id>https://eliasliangyu.github.io/2019/07/12/V2EX社区论坛推荐/</id>
    <published>2019-07-12T11:41:53.000Z</published>
    <updated>2019-07-12T13:07:11.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><b><a href="https://www.v2ex.com" target="_blank" rel="noopener">V2EX</a></b>，是一个汇集各类奇妙好玩的话题和流行动向的网站。V2EX 中充满了各种各样精心雕琢的细节。</p><p>尽管现在才说V2EX似乎有些晚了，即使是我也是今年初在少数派的分享文章中接触到，但不是有句名言叫做“Better late than never”，我坚信，总还是有朋友不了解V2EX的，总还是有朋友想了解他的。所以，在这里介绍下这个当初由大学生Livid创办的网站，你可以叫他社区、Wiki、架构或者BBS，但无论如何，他是一个神奇的网站。</p><p>2001 年，一个叫做Livid<b><a href="https://livid.v2ex.com" target="_blank" rel="noopener">(blog:https://livid.v2ex.com)</a></b>的高二学生用一套叫做 BBS3000 的 Perl CGI 程序搭建了一个学校的论坛。那个社区后来定名为 ePeta，Peta 是 10 的 15 次方。学校里几乎所有家里有网络（那个时候大家用的还是 56K 拨号）的同学都注册了那个社区，同时也扩展到了周围的学校。</p><p>2005 年 6 月的某个下午，正在做白日梦的Livid突然想起了V2EX 这个域名，于是立刻从床上跳起来注册了： </p><p><b>V2EX=way to explore|way too extreme</b> </p><p>2006 年 3 月，V2EX.com上线了……</p><p>经过多年的更新优化，现在的V2EX已经相当完善。</p><p><img src="//eliasliangyu.github.io/2019/07/12/V2EX社区论坛推荐/1.png" alt="网页端"></p><p>和现今让人眼花缭乱的论坛平台不同，V2EX是个极其干净简洁的技术类社区，除了风格和架构上的不同外,v2ex有一个最大的特点就是他的铜币（积分）制度：</p><p><img src="//eliasliangyu.github.io/2019/07/12/V2EX社区论坛推荐/3.png" alt="积分制度"></p><p>也就是说,你回帖需要扣积分,感谢别人要扣积分,甚至发布一个主题也要扣积分,这与拼命的设置隐藏/回复可见等通过激励用户灌水来赚取论坛繁荣的传统社区来说,简直是不可理喻的反人类之举，但一方面也使得用户更珍惜每次发言的机会，更好的维护了社区的良好氛围。</p><p>延伸阅读：</p><p><b><a href="https://www.douban.com/group/topic/121611313/" target="_blank" rel="noopener">专访Livid：不仅仅是V站站长</a></b></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="recommend" scheme="https://eliasliangyu.github.io/tags/recommend/"/>
    
  </entry>
  
  <entry>
    <title>Hi-ID博客推荐</title>
    <link href="https://eliasliangyu.github.io/2019/07/05/Hi-ID%E5%8D%9A%E5%AE%A2%E6%8E%A8%E8%8D%90/"/>
    <id>https://eliasliangyu.github.io/2019/07/05/Hi-ID博客推荐/</id>
    <published>2019-07-05T03:32:14.000Z</published>
    <updated>2019-07-05T04:12:12.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><b><a href="http://www.hi-id.com" target="_blank" rel="noopener">Hi-ID</a></b>是一个许久不更新的博客，冲浪时偶然发现，其内容着实有趣，从专利分析苹果的工业设计，算是谈论苹果工业设计的技术派，也是评判工业设计时为数不多靠谱的声音。</p><p><img src="//eliasliangyu.github.io/2019/07/05/Hi-ID博客推荐/1.png" alt="Hi-ID主页"></p><p>下面是我个人对Hi-ID博客中的几篇文章推荐。</p><p><b><a href="http://www.hi-id.com/?p=3535" target="_blank" rel="noopener">Apple 的 Logo 设计</a></b></p><p><b><a href="http://www.hi-id.com/?p=3286" target="_blank" rel="noopener">Apple “无缝”设计之历程</a></b></p><p><b><a href="http://www.hi-id.com/?p=3445" target="_blank" rel="noopener">从圆角到圆角</a></b></p><p><b><a href="http://www.hi-id.com/?p=4239" target="_blank" rel="noopener">Apple 那些“无关紧要”的设计改进</a></b></p><p><b><a href="http://www.hi-id.com/?p=4136" target="_blank" rel="noopener">HomePod 的设计</a></b></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="recommend" scheme="https://eliasliangyu.github.io/tags/recommend/"/>
    
  </entry>
  
  <entry>
    <title>OpenStack与飞天</title>
    <link href="https://eliasliangyu.github.io/2019/06/30/OpenStack%E4%B8%8E%E9%A3%9E%E5%A4%A9/"/>
    <id>https://eliasliangyu.github.io/2019/06/30/OpenStack与飞天/</id>
    <published>2019-06-29T16:22:02.000Z</published>
    <updated>2019-06-29T23:57:36.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天刚结束华为云的实训课程培训，对华为云的架构原理以及系统流程也算有一点了解。华为的实训人员一直强调华为云的技术优越性，那么和目前国内公有云实力排名第一的阿里云相比到底有哪些优势，又在哪些地方存在差距呢，我们都知道华为云是基于开源的OpenStack框架，而阿里云则是自研的“飞天”系统，查阅了官方文档，下面就来看看这两个框架的具体情况。</p><h1>OpenStack -华为云</h1><p><b><a href="https://eliasliangyu.github.io/2019/06/25/OpenStack%E6%9E%B6%E6%9E%84%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/">详见OpenStack架构知识梳理</a><b></b></b></p><h1>“飞天”-阿里云</h1><p>飞天是由阿里云开发的一个大规模分布式计算系统，其中包括飞天内核和飞天开放服务。</p><p>飞天内核负责管理数据中心Linux集群的物理资源，控制分布式程序运行， 隐藏下层故障恢复和数据冗余等细节，有效提供弹性计算和负载均衡。如图所示，飞天体系架构主要包含四大块：</p><p><img src="//eliasliangyu.github.io/2019/06/30/OpenStack与飞天/1.png" alt></p><ul><li>资源管理、安全、远程过程调用等构建分布式系统常用的底层服务;</li></ul><ul><li>分布式文件系统;</li></ul><ul><li>任务调度;</li></ul><ul><li>集群部署和监控。</li></ul><p></p><p>飞天开放服务为用户应用程序提供了计算和存储两方面的接口和服务，包括弹性计算服务(Elastic ComputeService，简称ECS)、开放存储服务(Open Storage Service，简称OSS)、开放结构化数据服务(Open Table Service，简称OTS)、关系型数据库服务(Relational Database Service，简称RDS)和开放数据处理服务(Open Data Processing Service，简称ODPS)，并基于弹性计算服务提供了云服务引擎(Aliyun Cloud Engine，简称ACE)作为第三方应用开发和Web 应用运行和托管的平台。</p><p>阿里云计算有限公司(简称“阿里云”)成立于2009年9月10日，致力于打造云计算的基础服务平台，注重为中小企业提供大规模、低成本、高可靠的云计算应用及服务。飞天开放平台(简称“飞天平台”或者“飞天”)是由阿里云自主研发完成的公共云计算平台，该平台所提供的服务于2011年7月28日在www.aliyun.com正式上线，推出了第一个云服务——弹性计算服务。截至本书出版时，阿里云已经推出了包括弹性计算服务、开放存储服务、关系型数据库服务、开放结构化数据服务在内的一系列服务和产品。</p><p>飞天平台内核包含的模块可以分为以下几部分。</p><p><strong>分布式系统底层服务：</strong>提供分布式环境下所需要的协调服务、远程过程调用、安全管理和资源管理的服务。这些底层服务为上层的分布式文件系统、任务调度等模块提供支持。<br><strong>分布式文件系统：</strong>提供一个海量的、可靠的、可扩展的数据存储服务，将集群中各个节点的存储能力聚集起来，并能够自动屏蔽软硬件故障，为用户提供不间断的数据访问服务；支持增量扩容和数据的自动平衡，提供类似于POSIX的用户空间文件访问API，支持随机读写和追加写的操作。<br><strong>任务调度：</strong>为集群系统中的任务提供调度服务，同时支持强调响应速度的在线服务(Online Service)和强调处理数据吞吐量的离线任务(Batch Processing Job)；自动检测系统中故障和热点，通过错误重试、针对长尾作业并发备份作业等方式，保证作业稳定可靠地完成。<br><strong>集群监控和部署：</strong>对集群的状态和上层应用服务的运行状态和性能指标进行监控，对异常事件产生警报和记录；为运维人员提供整个飞天平台以及上层应用的部署和配置管理，支持在线集群扩容、缩容和应用服务的在线升级。</p><h2>分布式系统底层服务</h2><h3>协调服务(女娲)</h3><p>女娲(Nuwa)系统为飞天提供高可用的协调服务(Coordination Service)，是构建各类分布式应用的核心服务，它的作用是采用类似文件系统的树形命名空间来让分布式进程互相协同工作。例如，当集群变更导致特定的服务被迫改变物理运行位置时，如服务器或者网络故障、配置调整或者扩容时，借助女娲系统可以使其他程序快速定位到该服务新的接入点，从而保证了整个平台的高可靠性和高可用性。</p><p>女娲系统基于类Paxos协议，由多个女娲Server以类似文件系统的树形结构存储数据，提供高可用、高并发用户请求的处理能力。</p><p>女娲系统的目录表示一个包含文件的集合。与UNIX中的文件路径一样，女娲中路径是以“/”分割的，根目录(Root entry)的名字是“/”，所有目录的名字都是以“/”结尾的。与UNIX文件路径不同之处在于：女娲系统中所有文件或目录都必须使用从根目录开始的绝对路径。由于女娲系统的设计目的是提供协调服务，而不是存储大量数据，所以每个文件的内容(Value)的大小被限制在1MB以内。在女娲系统中，每个文件或目录都保存有创建者的信息。一旦某个路径被用户创建，其他用户就可以访问和修改这个路径的值(即文件内容或目录包含的文件名)。</p><p>女娲系统支持Publish/Subscribe模式，其中一个发布者、多个订阅者(One Publisher/Many Subscriber)的模式提供了基本的订阅功能；另外，还可用通过多个发布者、多个订阅者(Many Publisher/Many Subscriber)的方式提供分布式选举(DistributedElection)和分布式锁的功能。</p><p>再举一个使用女娲系统来实现负载均衡的例子：提供某一服务的多个节点，在服务启动的时候在女娲系统的同一目录下创建文件，例如，server1创建文件“nuwa://cluster/ myservice/server1”，server2在同一目录下创建“nuwa://cluster/myservice/server2”。当客户端使用远程过程调用时，首先列举女娲系统服务中“nuwa://cluster/myservice”目录下的文件，这样就可以获得server1和server2，客户端随后可以从中选择一个节点发出自己的请求，从而实现负载均衡。</p><h3>远程过程调用(夸父)</h3><p>在分布式系统中，不同计算机之间只能通过消息交换的方式进行通信。显式的消息通信必须通过Socket接口编程，而远程过程调用(Remote Procedure Call，RPC)可以隐藏显式的消息交换，使得程序员可以像调用本地函数一样来调用远程的服务。</p><p>夸父(Kuafu)是飞天平台内核中负责网络通信的模块，它提供了一个RPC的接口，简化编写基于网络的分布式应用。夸父的设计目标是提供高可用(7×24小时)、大吞吐量(Gigabyte)、高效率、易用(简明API、多种协议和编程接口)的RPC服务。</p><p>RPC客户端(RPC Client)通过URI指定请求需要发送的RPC服务端(RPC Server)的地址，目前夸父支持两种协议形式。</p><p>TCP：例如，tcp://fooserver01:9000<br>Nuwa：例如，nuwa://nuwa01/FooServer</p><p>与用流(stream)传输的TCP通信相比，夸父通信是以消息(Message)为单位的，支持多种类型的消息对象，包括标准字符串std::string和基于std::map实现的若干string键值对。</p><p>夸父RPC同时支持异步(asynchronous)和同步(synchronous)的远程过程调用形式。</p><p>异步调用：RPC函数调用时不等接收到结果就会立即返回;用户必须通过显式调用接收函数取得请求结果。<br>同步调用：RPC函数调用时会等待，直到接收到结果才返回。在实现中，同步调用是通过封装异步调用来实现的。</p><p>在夸父的实现中，客户端程序通过Unix Domain Socket与本机上的一个夸父代理(Kuafu Proxy)连接，不同计算机之间的夸父代理会建立一个TCP连接。这样做的好处是可以更高效地使用网络带宽，系统可以支持上千台计算机之间的互联需求。此外，夸父利用女娲来实现负载均衡；对大块数据的传输做了优化；与TCP类似，夸父代理之间还实现了发送端和接收端的流控(Flow Control)机制。</p><h3>安全管理(钟馗)</h3><p>钟馗(Zhongkui)是飞天平台内核中负责安全管理的模块，它提供了以用户为单位的身份认证和授权，以及对集群数据资源和服务进行的访问控制。</p><p>用户的身份认证(Authentication)是基于密钥机制的。<br>用户对资源的访问控制是基于权能(Capability)机制进行授权(Authorization)的。</p><p>Capability是用于访问控制的一种数据结构，它定义了对一个或多个指定的资源(如目录、文件、表等)所具有的访问权限。用户访问飞天系统的资源时必须持有Capability，否则即视为非法。打一个比方，如果把Capability理解为地铁票，乘坐地铁(对地铁的一种访问方式)的时候必须要有Capability，即地铁票。</p><p>密钥对是基于公开密钥方法的，包括一个私钥和相对应的公钥。在飞天平台系统中，密钥对用于数字签名服务，以保证Capability的不可伪造。换句话说，私钥用于产生数字签名(如签发Capability)，公钥用于验证数字签名的有效性(如验证签发过的Capability的有效性)。</p><p>考虑到网络通信时任何通信节点都是不可信的，所以即使是飞天自身模块内部之间的通信也同样是需要认证和授权的，而且验证的机制也完全一样。</p><h2>分布式文件系统（盘古）</h2><p>盘古(Pangu)是一个分布式文件系统，盘古系统的设计目标是将大量通用机器的存储资源聚合在一起，为用户提供大规模、高可靠、高可用、高吞吐量和可扩展的存储服务，是飞天平台内核中的一个重要组成部分。</p><p><strong>大规模：</strong>能够支持数十PB量级的存储大小(1PB=1000TB)，总文件数量达到亿量级。<br><strong>数据高可靠性：</strong>保证数据和元数据(Metadata)是持久保存并能够正确访问的，保证所有数据存储在处于不同机架的多个节点上面(通常设置为3)。即使集群中的部分节点出现硬件和软件故障，系统能够检测到故障并自动进行数据的备份和迁移，保证数据的安全存在。<br><strong>服务高可用性：</strong>保证用户能够不中断地访问数据，降低系统的不可服务时间。即使出现软硬件的故障、异常和系统升级等情况，服务仍可正常访问。<br><strong>高吞吐量：</strong>运行时系统I/O吞吐量能够随机器规模线性增长，保证响应时间。<br><strong>高可扩展性：</strong>保证系统的容量能够通过增加机器的方式得到自动扩展，下线机器存储的数据能够自动迁移到新加入的节点上。</p><p>同时，盘古系统也能很好地支持在线应用的低延时需求。在盘古系统中，文件系统的元数据存储在多个主服务器(Master)上，文件内容存储在大量的块服务器(Chunk Server)上。客户端程序在使用盘古系统时，首先从主服务器获取元数据信息(包括接下来与哪些块服务器交互)，然后在块服务器上直接进行数据操作。由于元数据信息很小，大量的数据交互是客户端直接与块服务器进行的，因此盘古系统采用少量的主服务器来管理元数据，并使用Paxos协议保证元数据的一致性。此外，块大小被设置为64MB，进一步减少了元数据的大小，因此可以将元数据全部放到内存里，从而使得主服务器能够处理大量的并发请求。</p><p>块服务器负责存储大小为64MB的数据块。在向文件写入数据之前，客户端将建立到3个块服务器的连接，客户向主副本(Replica)写入数据以后，由主副本负责向其他副本发送数据。与直接由客户端向3个副本写入数据相比，这样可以减少客户端的网络带宽使用。块副本在放置的时候，为保证数据可用性和最大化地使用网络带宽，会将副本放置在不同机架上，并优先考虑磁盘利用率低的机器。当硬件故障或数据不可用造成数据块的副本数目不满3份时，数据块会被重新复制。为保证数据的完整性，每块数据在写入时会同时计算一个校验值，与数据同时写入磁盘。当读取数据块时，块服务器会再次计算校验值与之前存入的值是否相同，如果不同就说明数据出现了错误，需要从其他副本重新读取数据。</p><p>在线应用对盘古系统提出了与离线应用不同的挑战：OSS、OTS要求低时延数据读写，ECS在要求低时延的同时还需要具备随机写的能力。针对这些需求，盘古系统实现了事务日志文件和随机访问文件，用于支撑在线应用。其中，日志文件通过多种方法对时延进行了优化，包括设置更高的优先级、由客户端直接写多份拷贝而不是用传统的流水线方式、写入成功不经过Master确认等。随机访问文件则允许用户随机读写，同时也应用了类似日志文件的时延优化技术。</p><h2>资源管理和任务调度（伏羲）</h2><p>伏羲(Fuxi)是飞天平台内核中负责资源管理和任务调度的模块，同时也为应用开发提供了一套编程基础框架。伏羲同时支持强调响应速度的在线服务和强调处理数据吞吐量的离线任务。在伏羲中，这两类应用分别简称为Service和Job。</p><p>在资源管理方面，伏羲主要负责调度和分配集群的存储、计算等资源给上层应用；管理运行在集群节点上任务的生命周期；在多用户运行环境中，支持计算额度、访问控制、作业优先级和资源抢占，在保证公平的前提下，达到有效地共享集群资源。</p><p>在任务调度方面，伏羲面向海量数据处理和大规模计算类型的复杂应用，提供了一个数据驱动的多级流水线并行计算框架，在表述能力上兼容MapReduce、Map-Reduce-Merge等多种编程模式；自动检测故障和系统热点，重试失败任务，保证作业稳定可靠运行完成;具有高可扩展性，能够根据数据分布优化网络开销。</p><p>伏羲中应用了“Master/Worker”工作模型。其中，Master负责进行资源申请和调度、为Worker创建工作计划(Plan)并监控Worker的生命周期，Worker负责执行具体的工作计划并及时向Master汇报工作状态(Status)。此外，Master支持多级模式，即一个Master可以隶属于另外一个Master之下。</p><p>伏羲Master负责整个集群资源管理和调度，处理Job/Service启动、停止、Failover等生命周期的维护。同时伏羲Master支持多用户额度配置、Job/Service的多优先级设置和动态资源抢占逻辑，可以说是飞天平台的“大脑”。伏羲对资源调度是多维度的，可以根据CPU、内存等系统资源，以及应用自定义的虚拟资源对整个机群进行资源分配和调度。</p><p>土伯(Tubo)是部署在每台由伏羲管理的机器上的后台进程，负责收集并向伏羲Master报告本机的状态，包括系统资源的消耗、Master或Worker进程的运行、等待、完成和失败事件，并根据伏羲Master或者Job/Service Master的指令，启动或杀死指定的Master或Worker进程。同时土伯还负责对计算机健康状况进行监控，对异常Worker(比如内存超用)进行及时的清理和汇报。</p><p>对于在线服务(Service)，由伏羲Master负责ServiceMaster的启动与状态监控，处理相应Service Master的资源申请请求。Service Master负责管理Service Worker的任务分配、生命周期管理以及Failover的管理。</p><p>对于离线任务(Job)，伏羲Master负责Job Master的启动与状态监控，处理相应JobMaster的资源申请请求。Job Master根据用户输入的Job描述文件，将任务分解成一个或以上的Task，每个Task的资源申请、Task Worker的调度和生命周期维护由Task Master负责。</p><h3>在线服务调度</h3><p>在飞天平台内核中，每个Service都有一个ServiceMaster和多个不同角色(Role)的Service Worker，它们一起协同工作来完成整个服务的功能。Service Master是伏羲Master管理下的子Master(Child Master)，它负责这个Service相关的资源申请、状态维护以及故障恢复，并定期与伏羲Master进行交互，确保整个Service正确、正常地运行。每个Service Worker的角色和执行的动作，都是由用户来定义的。</p><p>每个ServiceWorker负责处理一个到多个数据分片(Partition)，同一时刻一个分片只会被分配到一个Service Worker处理。将数据分割成为互不相关的分片，然后将不同分片给不同Service Worker来处理是构建大规模应用服务的关键特性。数据分片是一个抽象的概念，在不同的应用中有不同的含义。</p><p>在服务运行的过程中，每个Service的数据分片的数目和内容都是可以动态变化的，应用程序可以根据实际需要对数据分片动态地进行加载(Load)、卸载(Unload)、分裂(Split)和迁移(Migrate)等操作。</p><h3>离线任务调度</h3><p>在飞天平台中，一个离线任务(Job)的执行过程被抽象为一个有向无环图(Directed Acyclic Graph，DAG)：图上每个顶点对应一个Task，每条边对应一个Pipeline。一个连接两个Task的Pipeline表示前一个Task的输出是后一个Task的输入。</p><p>每个离线任务都有一个JobMaster负责根据用户输入的任务描述(Job description)构造DAG和调度DAG中所有Task的执行。每个Task的Task Master会根据要处理的实例数量、数据在集群的分布及处理实例的资源需求，向伏羲Master申请机器资源并分配Task Worker在其上执行。分配到每台机器上的实例(Instance)是由Task Worker来具体执行完成的。每台机器上的Task Worker可以根据需要选择多线程或者多进程的不同运行模式。</p><p>在离线Job的容错方面，除了提供对异常机器的黑名单机制、长尾Instance的后备Worker机制外，伏羲还提供了快照(Snapshot)机制。快照是Task级别的容错机制。如果一个Task的n个Instance在前一次运行失败时完成了m个，那么Task重启后只会重新调度运行剩余的n−m个Instance。</p><h2>集群监控和部署</h2><h3>集群监控(神农)</h3><p>神农(Shennong)是飞天平台内核中负责信息收集、监控和诊断的模块。它通过在每台物理机器上部署轻量级的信息采集模块，获取各个机器的操作系统与应用软件运行状态，监控集群中的故障，并通过分析引擎对整个飞天的运行状态进行评估。</p><p>神农系统包括Master、Inspector和Agent三个部分。</p><p>Master：负责管理所有神农Agent，并对外提供统一的接口来处理神农用户的订阅(Subscription)请求，在集群中只有一个Master。<br>Inspector：是部署在每一台机器上的进程，负责采集当前机器和进程的通用信息，并实时发送给该机器上的神农Agent。<br>Agent：是部署在每台物理机器的后台程序。Agent负责接受来自应用和Inspector写入的信息。Agent启动后，会立刻向Master注册自己，并根据Master发来的订阅(Subscription)命令执行相应的信息采集、过滤、聚合和处理操作。目前神农Agent处理的数据分为两类：事件类数据(如应用程序故障和报警)和数值类数据(如当前应用的性能计数、机器I/O吞吐量等)。<br>　　神农的用户通过Master来访问神农系统，以数据订阅(Subscription)的方式获取神农系统采集到的信息。</p><p>神农的MonitorService和AnalysisService是使用神农系统的两个应用程序。</p><p>MonitorService在集群中的一台机器上部署，通过向各个Agent发送特定的监控请求，并根据配置设定的规则，实现对集群的状态和事件的监控，以及报警和记录。<br>AnalysisService也是部署在集群中的一台机器上，通过访问神农来获得主要性能数据，然后聚合数据并计算出系统的总体资源情况(例如，集群的总资源消耗、总I/O吞吐量等)，并且向外提供计算结果供查询。</p><h3>集群部署(大禹)</h3><p>大禹(Dayu)是飞天内核中负责提供配置管理和部署的模块，它包括一套为集群的运维人员提供的完整工具集，功能涵盖了集群配置信息的集中管理、集群的自动化部署、集群的在线升级、集群扩容、集群缩容，以及为其他模块提供集群基本信息等。每个飞天模块的发布包都包含一个部署升级的描述文件，定义了该模块部署和升级的流程，提供给大禹使用。</p><p>在结构上，大禹包含了集群配置数据库、节点守护进程、客户端工具集等部分。</p><p>集群配置数据库负责存放和管理所有部署了飞天的集群的配置信息，包括集群中每个节点承担的角色、各个模块的软件版本、各个模块的基本参数配置等。同时，数据库中还记录了部署或升级时每个节点的任务执行状态，保证了在部署或升级时少量不在线节点可以在重新连线后进行自动修复。</p><p>节点守护进程运行在集群的每一个节点上，负责与集群配置数据库同步该节点相关的集群信息，执行节点相关的具体运维任务，并汇报任务执行状态。节点守护进程本身是自我升级的，只需部署一次，即能保证运行的是该集群最适合的版本。在模块软件部署和升级的过程中，节点守护进程还负责软件的下载分发，为了保证效率和规避单点故障，软件的分发采用P2P的方式进行。</p><p>客户端工具集是运维人员实际使用的命令行工具和网页界面，运维人员通过这些工具对集群进行部署、升级、扩容、缩容等具体操作。大部分操作都提供了自动化和人机交互执行两种方式，分别适应简便操作和精细化控制这两种场景。在部署和升级的过程中，客户端工具负责控制总体的操作顺序，维护模块之间的依赖关系，并根据状态信息决定是否回滚或中断当前流程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="experience" scheme="https://eliasliangyu.github.io/tags/experience/"/>
    
  </entry>
  
  <entry>
    <title>SaaS PaaS LaaS</title>
    <link href="https://eliasliangyu.github.io/2019/06/29/SaaS-PaaS-LaaS/"/>
    <id>https://eliasliangyu.github.io/2019/06/29/SaaS-PaaS-LaaS/</id>
    <published>2019-06-29T14:30:49.000Z</published>
    <updated>2019-06-29T16:23:20.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>从小型企业到全球企业，云都是一个非常热门的话题，它是一个非常广泛的概念，涵盖了很多在线领域。 无论是应用程序还是基础架构部署，当你开始考虑将项目转移到云时，了解各种云服务的差异和优势就显得十分重要。</p><p>通常有三种云服务模型：SaaS（软件即服务），PaaS（平台即服务）和IaaS（基础架构即服务）。 每个都有自己的好处和差异。为了您的组织能作出最佳选择，您有必要了解SaaS，PaaS和IaaS之间的差异。</p><p>下图总结了三种模型的主要差别：</p><p><img alt class="has" height="453" src="https://blogs.bmc.com/wp-content/uploads/2017/09/iaas-paas-saas-comparison-1024x759.jpg" width="612"></p><h1>SaaS：软件即服务</h1><p>软件即服务（也称为云应用程序服务）代表了云市场中企业最常用的选项。 SaaS利用互联网向其用户提供应用程序，这些应用程序由第三方供应商管理。 大多数SaaS应用程序直接通过Web浏览器运行，不需要在客户端进行任何下载或安装。</p><h2>SaaS的交付</h2><p>由于其网络传输模式，SaaS无需在每台计算机上下载和安装应用程序，而在每台计算机上下载和安装应用程序正是IT员工的噩梦。 通过SaaS，供应商可以管理所有潜在的技术问题，例如数据、中间件，服务器和存储，因此企业可以简化其维护和支持。</p><h2>SaaS的优势</h2><p>SaaS通过大大减少安装，管理和升级软件等繁琐任务所花费的时间和金钱，为员工和公司提供了许多好处。 这让技术人员可以花更多时间来处理组织内更紧迫的事情和问题。</p><h2>SaaS的特点</h2><p>有方面可以帮助您确定何时使用SaaS：</p><ul><li>在统一的地方管理</li></ul><ul><li>托管在远程服务器上</li></ul><ul><li>可通过互联网访问</li></ul><ul><li>用户不负责硬件或软件更新</li></ul><h2>何时使用SaaS</h2><p>SaaS在许多场景情中是最有利的，包括：</p><ul><li>如果您是一家初创公司或小公司，需要快速启动电子商务，没有时间处理服务器问题或软件</li></ul><ul><li>适用于需要协作的短期项目</li></ul><ul><li>如果您需要不常用的应用程序，例如税务软件</li></ul><ul><li>适用于需要通过Web和移动访问的应用程序</li></ul><h2>SaaS的例子</h2><p>Google Apps、Dropbox、Salesforce、Cisco WebEx、Concur和GoToMeeting等</p><h1>PaaS：平台即服务</h1><p>云平台服务或平台即服务（PaaS）为某些软件提供云组件，这些组件主要用于应用程序。 PaaS为开发人员提供了一个框架，使他们可以基于它创建自定义应用程序。所有服务器，存储和网络都可以由企业或第三方提供商进行管理，而开发人员可以负责应用程序的管理。</p><h2>PaaS的交付</h2><p>PaaS的交付模式类似于SaaS，除了通过互联网提供软件，PaaS提供了一个软件创建平台。该平台通过Web提供，使开发人员可以自由地专注于创建软件，同时不必担心操作系统、软件更新，存储或基础架构。</p><p>PaaS允许企业使用特殊的软件组件设计和创建内置于PaaS中的应用程序。由于具有某些云特性，这些应用程序或中间件具有可扩展性和高可用性。</p><h2>PaaS的优势</h2><p>无论您的公司规模如何，使用PaaS都有很多优势：</p><ul><li>使应用程序的开发和部署变得简单且经济高效</li></ul><ul><li>可扩展</li></ul><ul><li>高度可用</li></ul><ul><li>使开发人员能够创建自定义应用程序，而无需维护软件</li></ul><ul><li>大大减少了编码量</li></ul><ul><li>自动化业务策略</li></ul><ul><li>允许轻松迁移到混合模型</li></ul><h2>PaaS的特点</h2><p>PaaS具有许多将其定义为云服务的特征，包括：</p><ul><li>它基于虚拟化技术，这意味着随着业务的变化，资源可以轻松扩展或缩小</li></ul><ul><li>提供各种服务以协助开发，测试和部署应用程序</li></ul><ul><li>许多用户可以访问相同的开发应用程序</li></ul><ul><li>Web服务和数据库是集成的</li></ul><h2>何时使用PaaS</h2><p>在许多情况下，使用PaaS是有益的甚至是必要的。 如果有多个开发人员在同一个开发项目上工作，或者必须包含其他供应商，PaaS可以为整个过程提供极大的速度和灵活性。 如果您希望能够创建自己的自定义应用程序，PaaS也是有益的。 云服务还可以大大降低成本，并且可以简化您在快速开发或部署应用程序时出现的一些挑战。</p><h2>PaaS的例子</h2><p>AWS Elastic Beanstalk、Windows Azure、Heroku、Force.com、Google App Engine，Apache Stratos，OpenShift。</p><h1>IaaS：基础架构即服务</h1><p>云基础架构服务称为基础架构即服务（IaaS），由高度可扩展和自动化的计算资源组成。 IaaS是完全自助服务，用于访问和监控计算、网络，存储和其他服务等内容，它允许企业按需求和需要购买资源，而不必购买全部硬件。</p><h2>IaaS的交付</h2><p>IaaS通过虚拟化技术为组织提供云计算基础架构，包括服务器、网络，操作系统和存储等。这些云服务器通常通过仪表盘或API提供给客户端，IaaS客户端可以完全控制整个基础架构。 IaaS提供与传统数据中心相同的技术和功能，而无需对其进行物理上的维护或管理。 IaaS客户端仍然可以直接访问其服务器和存储，但它们都通过云中的“虚拟数据中心”。</p><p>与SaaS或PaaS相反，IaaS客户端负责管理应用程序、运行时、操作系统，中间件和数据等方面。但是，IaaS的提供商管理服务器、硬盘驱动器、网络，虚拟化和存储。一些提供商甚至在虚拟化层之外提供更多服务，例如数据库或消息队列。</p><h2>IaaS的优势</h2><p>选择IaaS有很多好处，例如：</p><ul><li>是最灵活的云计算模型</li></ul><ul><li>轻松实现存储、网络，服务器和处理能力的自动部署</li></ul><ul><li>可以根据消耗量购买硬件</li></ul><ul><li>使客户能够完全控制其基础架构</li></ul><ul><li>可以根据需要购买资源</li></ul><ul><li>高度可扩展</li></ul><h2>IaaS的特点</h2><p>在考虑IaaS时要考虑的一些特征是：</p><ul><li>资源可作为服务提供</li></ul><ul><li>费用因消费而异</li></ul><ul><li>服务高度可扩展</li></ul><ul><li>通常在单个硬件上包括多个用户</li></ul><ul><li>为组织提供对基础架构的完全控制</li></ul><ul><li>动态灵活</li></ul><h2>何时使用IaaS</h2><p>与SaaS和PaaS一样，有些特定场景使用IaaS是最好的。如果您是初创公司或小公司，IaaS是一个很好的选择，因此您不必花费时间或金钱来创建硬件和软件。 有些大型组织希望完全控制其应用程序和基础架构，同时又想仅购买实际消耗或需要的硬，IaaS对他们也是有益的。对于快速发展的公司而言，IaaS可能是一个不错的选择，因为您不必在需求变化和发展时承诺使用特定的硬件或软件。如果您不确定新应用程序需要什么，这也会有所帮助，因为根据需要可以根据需要进行扩展或缩小。</p><h2>IaaS的例子</h2><p>DigitalOcean，Linode，Rackspace，AWS，Cisco Metapod，Microsoft Azure，Google Compute Engine（GCE）</p><h1>SaaS vs PaaS vs IaaS</h1><p>总体而言，每种云模型都提供了自己的特定功能和特性，因此您的解组织了解这些差异至关重要。 无论您是在寻找云存储软件，还是一个能创建定自定义应用程序的平滑平台，，或者希望完全控制整个基础架构而无需对其进行物理维护，您可以使用云服务。 无论您选择哪个选项，迁移到云都是业务和技术的未来，并且很必要让大家正确的了解这一点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="experience" scheme="https://eliasliangyu.github.io/tags/experience/"/>
    
  </entry>
  
  <entry>
    <title>Docker详细总结</title>
    <link href="https://eliasliangyu.github.io/2019/06/25/Docker%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>https://eliasliangyu.github.io/2019/06/25/Docker详细总结/</id>
    <published>2019-06-25T11:23:04.000Z</published>
    <updated>2019-06-28T02:04:31.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3>Docker是什么？</h3><p>在计算机技术日新月异的今天， <code>Docker</code> 在国内发展的如火如荼，特别是在一线互联网公司， <code>Docker</code> 的使用是十分普遍的，甚至成为了一些企业面试的加分项，不信的话看看下面这张图。</p><figure><div class="image-block"><img src="https://ask.qcloudimg.com/http-save/yehe-1564476/iqmvbjrv64.png"></div></figure><p>这是我在某招聘网站上看到的招聘 <strong>Java开发工程师</strong> 的招聘要求，其中有一条熟悉 <code>docker</code> 成为了你快速入职的加分项，由此可见熟悉 <code>docker</code> 在互联网公司的地位之重要。</p> <code>docker</code> 到底是个什么东西呢？<p></p><p>我们在理解 <code>docker</code> 之前，首先我们得先区分清楚两个概念，<strong>容器</strong>和<strong>虚拟机</strong>。</p><p>可能很多读者朋友都用过虚拟机，而对容器这个概念比较的陌生。</p><p>我们用的传统虚拟机如 <code>VMware</code> ， <code>VisualBox</code> 之类的需要模拟整台机器包括硬件，每台虚拟机都需要有自己的操作系统，虚拟机一旦被开启，预分配给它的资源将全部被占用。每一台虚拟机包括应用，必要的二进制和库，以及一个完整的用户操作系统。</p><p>而容器技术是和我们的宿主机共享硬件资源及操作系统，可以实现资源的动态分配。容器包含应用和其所有的依赖包，但是与其他容器共享内核。容器在宿主机操作系统中，在用户空间以分离的进程运行。</p><p>容器技术是实现操作系统虚拟化的一种途径，可以让您在资源受到隔离的进程中运行应用程序及其依赖关系。通过使用容器，我们可以轻松打包应用程序的代码、配置和依赖关系，将其变成容易使用的构建块，从而实现环境一致性、运营效率、开发人员生产力和版本控制等诸多目标。容器可以帮助保证应用程序快速、可靠、一致地部署，其间不受部署环境的影响。容器还赋予我们对资源更多的精细化控制能力，让我们的基础设施效率更高。通过下面这幅图我们可以很直观的反映出这两者的区别所在。</p><figure><div class="image-block"><img src="https://ask.qcloudimg.com/http-save/yehe-1564476/adj8jyeky9.png"></div></figure><p><strong>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</strong>它是目前最流行的 <code>Linux</code> 容器解决方案。</p><p>而 <code>Linux</code> 容器是 <code>Linux</code> 发展出了另一种虚拟化技术，简单来讲， <code>Linux</code> 容器不是模拟一个完整的操作系统，而是对进程进行隔离，相当于是在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。</p><p><code>Docker</code> 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 <code>Docker</code> ，就不用担心环境问题。</p><p>总体来说， <code>Docker</code> 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p><h3>Docker的优势</h3><p><strong>Docker相比于传统虚拟化方式具有更多的优势：</strong></p><ul class="ul-level-0" style="margin:10px 0 10px 20px"><li><code>docker</code> 启动快速属于秒级别。虚拟机通常需要几分钟去启动</li><li><code>docker</code> 需要的资源更少， <code>docker</code> 在操作系统级别进行虚拟化， <code>docker</code> 容器和内核交互，几乎没有性能损耗，性能优于通过 <code>Hypervisor</code> 层与内核层的虚拟化</li><li><code>docker</code> 更轻量， <code>docker</code> 的架构可以共用一个内核与共享应用程序库，所占内存极小。同样的硬件环境， <code>Docker</code> 运行的镜像数远多于虚拟机数量，对系统的利用率非常高</li><li>与虚拟机相比， <code>docker</code> 隔离性更弱， <code>docker</code> 属于进程之间的隔离，虚拟机可实现系统级别隔离</li><li>安全性： <code>docker</code> 的安全性也更弱。 <code>Docker</code> 的租户 <code>root</code> 和宿主机 <code>root</code> 等同，一旦容器内的用户从普通用户权限提升为root权限，它就直接具备了宿主机的root权限，进而可进行无限制的操作。虚拟机租户 <code>root</code> 权限和宿主机的 <code>root</code> 虚拟机权限是分离的，并且虚拟机利用如 <code>Intel</code> 的 <code>VT-d</code> 和 <code>VT-x</code> 的 <code>ring-1</code> 硬件隔离技术，这种隔离技术可以防止虚拟机突破和彼此交互，而容器至今还没有任何形式的硬件隔离，这使得容器容易受到攻击</li><li>可管理性： <code>docker</code> 的集中化管理工具还不算成熟。各种虚拟化技术都有成熟的管理工具，例如 <code>VMware vCenter</code> 提供完备的虚拟机管理能力</li><li>高可用和可恢复性： <code>docker</code> 对业务的高可用支持是通过快速重新部署实现的。虚拟化具备负载均衡，高可用，容错，迁移和数据保护等经过生产实践检验的成熟保障机制， <code>VMware</code> 可承诺虚拟机 <code>99.999%</code> 高可用，保证业务连续性</li><li>快速创建、删除：虚拟化创建是分钟级别的， <code>Docker</code> 容器创建是秒级别的， <code>Docker</code> 的快速迭代性，决定了无论是开发、测试、部署都可以节约大量时间</li><li>交付、部署：虚拟机可以通过镜像实现环境交付的一致性，但镜像分发无法体系化。 <code>Docker</code> 在 <code>Dockerfile</code> 中记录了容器构建过程，可在集群中实现快速分发和快速部署</li></ul><p>我们可以从下面这张表格很清楚地看到容器相比于传统虚拟机的特性的优势所在：</p><div class="table-wrapper"><table><thead><tr><th style="text-align:left"><div class="table-header"><p>特性</p></div></th><th style="text-align:left"><div class="table-header"><p>容器</p></div></th><th style="text-align:left"><div class="table-header"><p>虚拟机</p></div></th></tr></thead><tbody><tr><td style="text-align:left"><div class="table-cell"><p>启动</p></div></td><td style="text-align:left"><div class="table-cell"><p>秒级</p></div></td><td style="text-align:left"><div class="table-cell"><p>分钟级</p></div></td></tr><tr><td style="text-align:left"><div class="table-cell"><p>硬盘使用</p></div></td><td style="text-align:left"><div class="table-cell"><p>一般为MB</p></div></td><td style="text-align:left"><div class="table-cell"><p>一般为GB</p></div></td></tr><tr><td style="text-align:left"><div class="table-cell"><p>性能</p></div></td><td style="text-align:left"><div class="table-cell"><p>接近原生</p></div></td><td style="text-align:left"><div class="table-cell"><p>弱于</p></div></td></tr><tr><td style="text-align:left"><div class="table-cell"><p>系统支持量</p></div></td><td style="text-align:left"><div class="table-cell"><p>单机支持上千个容器</p></div></td><td style="text-align:left"><div class="table-cell"><p>一般是几十个</p></div></td></tr></tbody></table></div><h3>Docker的三个基本概念</h3><figure><div class="image-block"><img src="https://ask.qcloudimg.com/http-save/yehe-1564476/5t3jwtp4uj.jpeg"></div></figure><p>从上图我们可以看到，<code>Docker</code> 中包括三个基本的概念：</p><ul class="ul-level-0" style="margin:10px 0 10px 20px"><li><code>Image</code>(镜像)</li><li><code>Container</code>(容器)</li><li><code>Repository</code>(仓库)</li></ul><p>镜像是 <code>Docker</code> 运行容器的前提，仓库是存放镜像的场所，可见镜像更是 <code>Docker</code> 的核心。</p><h4>Image (镜像)</h4><p>那么镜像到底是什么呢？</p><p><code>Docker</code> 镜像可以看作是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><p>镜像<code>（Image）</code>就是一堆只读层<code>（read-only layer）</code>的统一视角，也许这个定义有些难以理解，下面的这张图能够帮助读者理解镜像的定义。</p><figure><div class="image-block"><img src="https://ask.qcloudimg.com/http-save/yehe-1564476/0053p9ipeb.png"></div></figure><p>从左边我们看到了多个只读层，它们重叠在一起。除了最下面一层，其它层都会有一个指针指向下一层。这些层是<code>Docker</code> 内部的实现细节，并且能够在主机的文件系统上访问到。统一文件系统 <code>(union file system)</code> 技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角，这样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统。我们可以在图片的右边看到这个视角的形式。</p><h4>Container (容器)</h4><p>容器 <code>(container)</code> 的定义和镜像 <code>(image)</code> 几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。</p><figure><div class="image-block"><img src="https://ask.qcloudimg.com/http-save/yehe-1564476/lc99kudzhe.png"></div></figure><p>由于容器的定义并没有提及是否要运行容器，所以实际上，容器 = 镜像 + 读写层。</p><h4>Repository (仓库)</h4><p><code>Docker</code> 仓库是集中存放镜像文件的场所。镜像构建完成后，可以很容易的在当前宿主上运行，但是， 如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，<code>Docker Registry</code> (仓库注册服务器)就是这样的服务。有时候会把仓库 <code>(Repository)</code> 和仓库注册服务器 <code>(Registry)</code> 混为一谈，并不严格区分。<code>Docker</code> 仓库的概念跟 <code>Git</code> 类似，注册服务器可以理解为 <code>GitHub</code> 这样的托管服务。实际上，一个 <code>Docker Registry</code> 中可以包含多个仓库 <code>(Repository)</code> ，每个仓库可以包含多个标签 <code>(Tag)</code>，每个标签对应着一个镜像。所以说，镜像仓库是 <code>Docker</code> 用来集中存放镜像文件的地方类似于我们之前常用的代码仓库。</p><p>通常，<strong>一个仓库会包含同一个软件不同版本的镜像</strong>，而<strong>标签就常用于对应该软件的各个版本</strong> 。我们可以通过<code>&lt;仓库名&gt;:&lt;标签&gt;</code>的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <code>latest</code> 作为默认标签.。</p><p>仓库又可以分为两种形式：</p><ul class="ul-level-0" style="margin:10px 0 10px 20px"><li><code>public</code>(公有仓库)</li><li><code>private</code>(私有仓库)</li></ul><p><code>Docker Registry</code> 公有仓库是开放给用户使用、允许用户管理镜像的 <code>Registry</code> 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p><p>除了使用公开服务外，用户还可以在本地搭建私有 <code>Docker Registry</code> 。<code>Docker</code> 官方提供了 <code>Docker Registry</code> 镜像，可以直接使用做为私有 <code>Registry</code> 服务。当用户创建了自己的镜像之后就可以使用 <code>push</code> 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 <code>pull</code> 下来就可以了。</p><p>我们主要把 <code>Docker</code> 的一些常见概念如 <code>Image</code> ， <code>Container</code> ， <code>Repository</code> 做了详细的阐述，也从传统虚拟化方式的角度阐述了 <code>docker</code> 的优势，我们从下图可以直观地看到 <code>Docker</code> 的架构：</p><figure><div class="image-block"><img src="https://ask.qcloudimg.com/http-save/yehe-1564476/1atvhdm6gn.png"></div></figure><p><code>Docker</code> 使用 <code>C/S</code> 结构，即<strong>客户端/服务器</strong>体系结构。 <code>Docker</code> 客户端与 <code>Docker</code> 服务器进行交互，Docker服务端负责构建、运行和分发 <code>Docker</code> 镜像。 <code>Docker</code> 客户端和服务端可以运行在一台机器上，也可以通过 <code>RESTful</code> 、 <code>stock</code> 或网络接口与远程 <code>Docker</code> 服务端进行通信。</p><figure><div class="image-block"><img src="https://ask.qcloudimg.com/http-save/yehe-1564476/algzrsmdja.png"></div></figure><p>这张图展示了 <code>Docker</code> 客户端、服务端和 <code>Docker</code> 仓库（即 <code>Docker Hub</code> 和 <code>Docker Cloud</code> ），默认情况下<code>Docker</code> 会在 <code>Docker</code> 中央仓库寻找镜像文件，这种利用仓库管理镜像的设计理念类似于 <code>Git</code> ，当然这个仓库是可以通过修改配置来指定的，甚至我们可以创建我们自己的私有仓库。</p><h3>Docker的安装和使用</h3><p><code>Docker</code> 的安装和使用有一些前提条件，主要体现在体系架构和内核的支持上。对于体系架构，除了 <code>Docker</code> 一开始就支持的 <code>X86-64</code> ，其他体系架构的支持则一直在不断地完善和推进中。</p><p><code>Docker</code> 分为 <code>CE</code> 和 <code>EE</code> 两大版本。 <code>CE</code> 即社区版（免费，支持周期 <code>7</code> 个月）， <code>EE</code> 即企业版，强调安全，付费使用，支持周期 <code>24</code> 个月。</p><p>我们在安装前可以参看官方文档获取最新的 <code>Docker</code> 支持情况，官方文档在这里：</p><pre class="prism-token token language-javascript">https://docs.docker.com/install/</pre><p><code>Docker</code> 对于内核支持的功能，即内核的配置选项也有一定的要求(比如必须开启 <code>Cgroup</code> 和 <code>Namespace</code> 相关选项，以及其他的网络和存储驱动等)， <code>Docker</code> 源码中提供了一个检测脚本来检测和指导内核的配置，脚本链接在这里：</p><pre class="prism-token token language-javascript">https://raw.githubusercontent.com/docker/docker/master/contrib/check-config.sh</pre><p>在满足前提条件后，安装就变得非常的简单了。</p><p><code>Docker CE</code> 的安装请参考官方文档：</p><ul class="ul-level-0" style="margin:10px 0 10px 20px"><li><code>MacOS</code>：https://docs.docker.com/docker-for-mac/install/</li><li><code>Windows</code>：https://docs.docker.com/docker-for-windows/install/</li><li><code>Ubuntu</code>：https://docs.docker.com/install/linux/docker-ce/ubuntu/</li><li><code>Debian</code>：https://docs.docker.com/install/linux/docker-ce/debian/</li><li><code>CentOS</code>：https://docs.docker.com/install/linux/docker-ce/centos/</li><li><code>Fedora</code>：https://docs.docker.com/install/linux/docker-ce/fedora/</li><li>其他 <code>Linux</code> 发行版：https://docs.docker.com/install/linux/docker-ce/binaries/</li></ul><p>这里我们以 <code>CentOS7</code> 作为本文的演示。</p><h4>环境准备</h4><ul class="ul-level-0" style="margin:10px 0 10px 20px"><li><strong>阿里云服务器(1核2G，1M带宽)</strong></li><li><strong>CentOS 7.4 64位</strong></li></ul><p>由于 <code>Docker-CE</code> 支持 <code>64</code> 位版本的 <code>CentOS7</code> ，并且要求内核版本不低于 <code>3.10</code></p><p>首先我们需要卸载掉旧版本的 <code>Docker</code></p><pre class="prism-token token language-javascript">$ sudo yum remove docker \                  docker-client \                  docker-client-latest \                  docker-common \                  docker-latest \                  docker-latest-logrotate \                  docker-logrotate \                  docker-selinux \                  docker-engine-selinux \                  docker-engine</pre><figure><div class="image-block"><span class="lazy-image-holder" dataurl="https://ask.qcloudimg.com/http-save/yehe-1564476/787myiuzv5.png"></span></div></figure><p>我们执行以下安装命令去安装依赖包：</p><pre class="prism-token token language-javascript">$ sudo yum install -y yum-utils \           device-mapper-persistent-data \           lvm2</pre><p>这里我事先已经安装过了，所以提示我已经安装了最新版本</p><figure><div class="image-block"><span class="lazy-image-holder" dataurl="https://ask.qcloudimg.com/http-save/yehe-1564476/vjybno5dob.png"></span></div></figure><p><strong>安装Docker</strong></p><p><code>Docker</code> 软件包已经包括在默认的 <code>CentOS-Extras</code> 软件源里。因此想要安装 <code>docker</code>，只需要运行下面的 <code>yum</code> 命令</p><pre class="prism-token token language-javascript">$ sudo yum install docker</pre><p>当然在测试或开发环境中 <code>Docker</code> 官方为了简化安装流程，提供了一套便捷的安装脚本，<code>CentOS</code> 系统上可以使用这套脚本安装：</p><pre class="prism-token token language-javascript">curl -fsSL get.docker.com -o get-docker.shsh get-docker.sh</pre><p>具体可以参看 <code>docker-install</code> 的脚本：</p><pre class="prism-token token language-javascript">https://github.com/docker/docker-install</pre><p>执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 <code>Docker CE</code> 的 <code>Edge</code> 版本安装在系统中。</p><p>安装完成后，运行下面的命令，验证是否安装成功：</p><pre class="prism-token token language-javascript">docker versionordocker info</pre><p>返回docker的版本相关信息，证明 <code>docker</code> 安装成功</p><figure><div class="image-block"><img src="https://ask.qcloudimg.com/http-save/yehe-1564476/4uwhppc74n.png"></div></figure><p>启动Docker-CE</p><pre class="prism-token token language-javascript">$ sudo systemctl enable docker$ sudo systemctl start docker</pre><h4>Docker的简单运用---Hello World</h4><p>由于服务器日常崩溃了， <code>docker</code> 出了点问题，所以以下案例的演示是基于 <code>Kali Linux</code> 环境下进行的。</p><p>我们通过最简单的 <code>image</code> 文件 <code>hello world</code>，感受一下 <code>Docker</code> 的魅力吧！</p><p>我们直接运行下面的命令，将名为 <code>hello-world</code> 的 <code>image</code> 文件从仓库抓取到本地。</p><pre class="prism-token token language-javascript">docker pull library/hello-world</pre><p><code>docker pull images</code> 是抓取 <code>image</code> 文件， <code>library/hello-world</code> 是 <code>image</code> 文件在仓库里面的位置，其中 <code>library</code> 是 <code>image</code> 文件所在的组， <code>hello-world</code> 是 <code>image</code> 文件的名字。</p><figure><div class="image-block"><img src="https://ask.qcloudimg.com/http-save/yehe-1564476/t64sq618k4.png"></div></figure><p>抓取成功以后，就可以在本机看到这个 <code>image</code> 文件了。</p><pre class="prism-token token language-javascript">docker images</pre><p>我们可以看到如下结果：</p><figure><div class="image-block"><img src="https://ask.qcloudimg.com/http-save/yehe-1564476/kyx2h0okvt.png"></div></figure><p>现在，我们可以运行 <code>hello-world</code> 这个 <code>image</code> 文件</p><pre class="prism-token token language-javascript">docker run hello-world</pre><p>我们可以看到如下结果：</p><figure><div class="image-block"><img src="https://ask.qcloudimg.com/http-save/yehe-1564476/pg26nxbavs.png"></div></figure><p>输出这段提示以后，<code>hello world</code> 就会停止运行，容器自动终止。有些容器不会自动终止，因为提供的是服务，比如Mysql镜像等。</p><p>是不是很 <code>easy</code> 呢？我们从上面可以看出， <code>docker</code> 的功能是十分强大的，除此之外，我们还可以拉去一些 <code>Ubuntu</code> ， <code>Apache</code> 等镜像，在未来的教程中我们将会一一提到。</p><p><code>Docker</code> 提供了一套简单实用的命令来创建和更新镜像，我们可以通过网络直接下载一个已经创建好了的应用镜像，并通过 <code>Docker RUN</code> 命令就可以直接使用。当镜像通过 <code>RUN</code> 命令运行成功后，这个运行的镜像就是一个 <code>Docker</code> 容器啦，容器可以理解为一个轻量级的沙箱， <code>Docker</code> 利用容器来运行和隔离应用，容器是可以被启动、停止、删除的，这并不会影响 <code>Docker</code> 镜像。</p><p>我们可以看看下面这幅图：</p><figure><div class="image-block"><img src="https://ask.qcloudimg.com/http-save/yehe-1564476/1vege8gru2.png"></div></figure><p><code>Docker</code> 客户端是 <code>Docker</code> 用户与 <code>Docker</code> 交互的主要方式。当您使用 <code>docker</code> 命令行运行命令时， <code>Docker</code> 客户端将这些命令发送给服务器端，服务端将执行这些命令。 <code>docker</code> 命令使用 <code>docker API</code> 。 <code>Docker</code> 客户端可以与多个服务端进行通信。</p><p>我们将剖析一下 <code>Docker</code> 容器是如何工作的，学习好Docker容器工作的原理，我们就可以自己去管理我们的容器了。</p><h3>Docker架构</h3><p>在上面的学习中，我们简单地讲解了Docker的基本架构。了解到了<code>Docker</code> 使用的是 <code>C/S</code> 结构，即<strong>客户端/服务器</strong>体系结构。明白了 <code>Docker</code> 客户端与 <code>Docker</code> 服务器进行交互时， <code>Docker</code> 服务端负责构建、运行和分发 <code>Docker</code> 镜像。 也知道了<code>Docker</code> 客户端和服务端可以运行在一台机器上，可以通过 <code>RESTful</code> 、 <code>stock</code> 或网络接口与远程 <code>Docker</code> 服务端进行通信。</p><p>我们从下图可以很直观的了解到Docker的架构：</p><figure><div class="image-block"><img src="https://ask.qcloudimg.com/http-save/yehe-1564476/coy2vf1tjr.png"></div></figure><p><code>Docker</code> 的核心组件包括：</p><ol class="ol-level-0"><li><strong>Docker Client</strong></li><li><strong>Docker daemon</strong></li><li><strong>Docker Image</strong></li><li><strong>Docker Registry</strong></li><li><strong>Docker Container</strong></li></ol><p><code>Docker</code> 采用的是 <code>Client/Server</code> 架构。客户端向服务器发送请求，服务器负责构建、运行和分发容器。客户端和服务器可以运行在同一个 <code>Host</code> 上，客户端也可以通过 <code>socket</code> 或 <code>REST API</code> 与远程的服务器通信。可能很多朋友暂时不太理解一些东西，比如 <code>REST API</code> 是什么东西等，不过没关系，在后面的文章中会一一给大家讲解清楚。</p><h4>Docker Client</h4><p><code>Docker Client</code> ，也称 <code>Docker</code> 客户端。它其实就是 <code>Docker</code> 提供命令行界面 <code>(CLI)</code> 工具，是许多 <code>Docker</code> 用户与 <code>Docker</code> 进行交互的主要方式。客户端可以构建，运行和停止应用程序，还可以远程与<code>Docker_Host</code>进行交互。最常用的 <code>Docker</code> 客户端就是 <code>docker</code> 命令，我们可以通过 <code>docker</code> 命令很方便地在 <code>host</code> 上构建和运行 <code>docker</code> 容器。</p><figure><div class="image-block"><img src="https://ask.qcloudimg.com/http-save/yehe-1564476/cey873vnaw.png"></div></figure><h4>Docker daemon</h4><p><code>Docker daemon</code> 是服务器组件，以 <code>Linux</code> 后台服务的方式运行，是 <code>Docker</code> 最核心的后台进程，我们也把它称为守护进程。它负责响应来自 <code>Docker Client</code> 的请求，然后将这些请求翻译成系统调用完成容器管理操作。该进程会在后台启动一个 <code>API Server</code> ，负责接收由 <code>Docker Client</code> 发送的请求，接收到的请求将通过<code>Docker daemon</code> 内部的一个路由分发调度，由具体的函数来执行请求。</p><figure><div class="image-block"><img src="https://ask.qcloudimg.com/http-save/yehe-1564476/8cz693q5sg.png"></div></figure><p>我们大致可以将其分为以下三部分：</p><ul class="ul-level-0" style="margin:10px 0 10px 20px"><li><strong>Docker Server</strong></li><li><strong>Engine</strong></li><li><strong>Job</strong></li></ul><p><strong>Docker Daemon</strong>的架构如下所示：</p><figure><div class="image-block"><img src="https://ask.qcloudimg.com/http-save/yehe-1564476/pisn4n7m4z.jpeg"></div></figure><p><code>Docker Daemon</code> 可以认为是通过 <code>Docker Server</code> 模块接受 <code>Docker Client</code> 的请求，并在 <code>Engine</code> 中处理请求，然后根据请求类型，创建出指定的 <code>Job</code> 并运行。 <code>Docker Daemon</code> 运行在 <code>Docker host</code> 上，负责创建、运行、监控容器，构建、存储镜像。</p><p>运行过程的作用有以下几种可能：</p><ul class="ul-level-0" style="margin:10px 0 10px 20px"><li>向 <code>Docker Registry</code> 获取镜像</li><li>通过 <code>graphdriver</code> 执行容器镜像的本地化操作</li><li>通过 <code>networkdriver</code> 执行容器网络环境的配置</li><li>通过 <code>execdriver</code> 执行容器内部运行的执行工作</li></ul><p>由于 <code>Docker Daemon</code> 和 <code>Docker Client</code> 的启动都是通过可执行文件 <code>docker</code> 来完成的，因此两者的启动流程非常相似。 <code>Docker</code> 可执行文件运行时，运行代码通过不同的命令行 <code>flag</code> 参数，区分两者，并最终运行两者各自相应的部分。</p><p>启动 <code>Docker Daemon</code> 时，一般可以使用以下命令来完成</p><pre class="prism-token token language-javascript">docker --daemon = truedocker –ddocker –d = true</pre><p>再由 <code>docker</code> 的 <code>main()</code> 函数来解析以上命令的相应 <code>flag</code> 参数，并最终完成 <code>Docker Daemon</code> 的启动。</p><p>下图可以很直观地看到 <code>Docker Daemon</code> 的启动流程：</p><figure><div class="image-block"><img src="https://ask.qcloudimg.com/http-save/yehe-1564476/5mo01qrxp4.jpeg"></div></figure><p>默认配置下， <code>Docker daemon</code> 只能响应来自本地 <code>Host</code> 的客户端请求。如果要允许远程客户端请求，需要在配置文件中打开 <code>TCP</code> 监听。我们可以照着如下步骤进行配置：</p><p>1、编辑配置文件 <code>/etc/systemd/system/multi-user.target.wants/docker.service</code> ，在环境变量 <code>ExecStart</code> 后面添加 <code>-H tcp://0.0.0.0</code>，允许来自任意 IP 的客户端连接。</p><figure><div class="image-block"><img src="https://ask.qcloudimg.com/http-save/yehe-1564476/f8iuzcr1zb.jpeg"></div></figure><p>2、重启 <code>Docker daemon</code></p><pre class="prism-token token language-javascript">systemctl daemon-reloadsystemctl restart docker.service</pre><p>3、我们通过以下命令即可实现与远程服务器通信</p><pre class="prism-token token language-javascript">docker -H 服务器IP地址 info</pre><p><code>-H</code> 是用来指定服务器主机， <code>info</code> 子命令用于查看 <code>Docker</code> 服务器的信息</p><h4>Docker Image</h4><p><code>Docker</code> 镜像可以看作是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。我们可将 <code>Docker</code> 镜像看成只读模板，通过它可以创建 <code>Docker</code> 容器。</p><p>镜像有多种生成方法：</p><ol class="ol-level-0"><li>从无到有开始创建镜像</li><li>下载并使用别人创建好的现成的镜像</li><li>在现有镜像上创建新的镜像</li></ol><p>我们可以将镜像的内容和创建步骤描述在一个文本文件中，这个文件被称作 <code>Dockerfile</code> ，通过执行 <code>docker build &lt;docker-file&gt;</code> 命令可以构建出 Docker 镜像，在后续的教程中，我们会用一篇专门讨论这个问题。</p><h4>Docker Registry</h4><p><code>Docker registry</code> 是存储 <code>docker image</code> 的仓库，它在 <code>docker</code> 生态环境中的位置如下图所示：</p><figure><div class="image-block"><img src="https://ask.qcloudimg.com/http-save/yehe-1564476/ob6c1fpn2v.jpeg"></div></figure><p>运行<code>docker push</code>、<code>docker pull</code>、<code>docker search</code>时，实际上是通过 <code>docker daemon</code> 与 <code>docker registry</code> 通信。</p><h4>Docker Container</h4><p><code>Docker</code> 容器就是 <code>Docker</code> 镜像的运行实例，是真正运行项目程序、消耗系统资源、提供服务的地方。 <code>Docker Container</code> 提供了系统硬件环境，我们可以使用 <code>Docker Images</code> 这些制作好的系统盘，再加上我们所编写好的项目代码， <code>run</code> 一下就可以提供服务啦。</p><h3>Docker组件是如何协作运行容器</h3><p>看到这里，我相信各位读者朋友们应该已经对Docker基础架构已经熟悉的差不多了，我们还记得运行的第一个容器吗？现在我们再通过hello-world这个例子来体会一下 <code>Docker</code> 各个组件是如何协作的。</p><p>容器启动过程如下：</p><ul class="ul-level-0" style="margin:10px 0 10px 20px"><li><code>Docker</code> 客户端执行 <code>docker run</code> 命令</li><li><code>Docker daemon</code> 发现本地没有 <code>hello-world</code> 镜像</li><li><code>daemon</code> 从 <code>Docker Hub</code> 下载镜像</li><li>下载完成，镜像 <code>hello-world</code> 被保存到本地</li><li><code>Docker daemon</code> 启动容器</li></ul><p>具体过程可以看如下这幅演示图：</p><figure><div class="image-block"><img src="https://ask.qcloudimg.com/http-save/yehe-1564476/37mibm0lh4.png"></div></figure><p>我们可以通过<code>docker images</code> 可以查看到 <code>hello-world</code> 已经下载到本地</p><figure><div class="image-block"><img src="https://ask.qcloudimg.com/http-save/yehe-1564476/gijce9xtub.png"></div></figure><p>我们可以通过<code>docker ps</code> 或者 <code>docker container ls</code> 显示正在运行的容器，我们可以看到， <code>hello-world</code> 在输出提示信息以后就会停止运行，容器自动终止，所以我们在查看的时候没有发现有容器在运行。</p><figure><div class="image-block"><img src="https://ask.qcloudimg.com/http-save/yehe-1564476/sjbdzwywy4.png"></div></figure><p>我们把 <code>Docker</code> 容器的工作流程剖析的十分清楚了，我们大体可以知道 <code>Docker</code> 组件协作运行容器可以分为以下几个过程：</p><ol class="ol-level-0"><li><code>Docker</code> 客户端执行 <code>docker run</code> 命令</li><li><code>Docker daemon</code> 发现本地没有我们需要的镜像</li><li><code>daemon</code> 从 <code>Docker Hub</code> 下载镜像</li><li>下载完成后，镜像被保存到本地</li><li><code>Docker daemon</code> 启动容器</li></ol><p>了解了这些过程以后，我们再来理解这些命令就不会觉得很突兀了，下面我来给大家讲讲 <code>Docker</code> 常用的一些命令操作吧。</p><h3>Docker常用命令</h3><p>我们可以通过 <code>docker -h</code> 去查看命令的详细的帮助文档。在这里我只会讲一些平常日常比赛或者生活中我们可能会用的比较多的一些命令。</p><figure><div class="image-block"><img src="https://ask.qcloudimg.com/http-save/yehe-1564476/ymyw6x0a2z.png"></div></figure><p>例如，我们需要拉取一个 <code>docker</code> 镜像，我们可以用如下命令：</p><pre class="prism-token token language-javascript">docker pull image_name</pre><p><code>image_name</code> 为镜像的名称，而如果我们想从 <code>Docker Hub</code> 上去下载某个镜像，我们可以使用以下命令：</p><pre class="prism-token token language-javascript">docker pull centos:latest</pre><p><code>centos:lastest</code> 是镜像的名称， <code>Docker daemon</code> 发现本地没有我们需要的镜像，会自动去 <code>Docker Hub</code> 上去下载镜像，下载完成后，该镜像被默认保存到 <code>/var/lib/docker</code> 目录下。</p><p>接着我们如果想查看下主机下存在多少镜像，我们可以用如下命令：</p><pre class="prism-token token language-javascript">docker images</pre><p>我们要想知道当前有哪些容器在运行，我们可以用如下命令：</p><pre class="prism-token token language-javascript">docker ps -a</pre><p><code>-a</code> 是查看当前所有正在运行的容器</p><p>我们该如何去对一个容器进行启动，重启和停止呢？我们可以用如下命令：</p><pre class="prism-token token language-javascript">docker start container_name/container_iddocker restart container_name/container_iddocker stop container_name/container_id</pre><p>这个时候我们如果想进入到这个容器中，我们可以使用 <code>attach</code> 命令：</p><pre class="prism-token token language-javascript">docker attach container_name/container_id</pre><p>那如果我们想运行这个容器中的镜像的话，并且调用镜像里面的 <code>bash</code> ，我们可以使用如下命令：</p><pre class="prism-token token language-javascript">docker run -t -i container_name/container_id /bin/bash</pre><p>那如果这个时候，我们想删除指定镜像的话，由于 <code>image</code> 被某个 <code>container</code> 引用（拿来运行），如果不将这个引用的 <code>container</code> 销毁（删除），那 <code>image</code> 肯定是不能被删除。我们首先得先去停止这个容器：</p><pre class="prism-token token language-javascript">docker ps -adocker stop container_name/container_id</pre><p>然后我们用如下命令去删除这个容器：</p><pre class="prism-token token language-javascript">docker rm container_name/container_id</pre><p>然后这个时候我们再去删除这个镜像：</p><pre class="prism-token token language-javascript">docker rmi image_name</pre><p>此时，常用的 <code>Docker</code> 相关的命令就讲到这里为止了，我们在后续的文章中还会反复地提到这些命令。</p><h3>Dockerfile是什么</h3><p>前面我们已经提到了 <code>Docker</code> 的一些基本概念。以 <code>CTF</code> 选手的角度来看，我们可以去使用 <code>Dockerfile</code> 定义镜像，依赖镜像来运行容器，可以去模拟出一个真实的漏洞场景。因此毫无疑问的说， <code>Dockerfile</code> 是镜像和容器的关键，并且 <code>Dockerfile</code> 还可以很轻易的去定义镜像内容，说了这么多，那么 <code>Dockerfile</code> 到底是个什么东西呢？</p><p><code>Dockerfile</code> 是自动构建 <code>docker</code> 镜像的配置文件， 用户可以使用 <code>Dockerfile</code> 快速创建自定义的镜像。<code>Dockerfile</code> 中的命令非常类似于 <code>linux</code> 下的 <code>shell</code> 命令。</p><p>我们可以通过下面这幅图来直观地感受下 Docker 镜像、容器和 Dockerfile 三者之间的关系。</p><figure><div class="image-block"><img src="https://ask.qcloudimg.com/http-save/yehe-1564476/lyzjwi0166.png"></div></figure><p>我们从上图中可以看到， <code>Dockerfile</code> 可以自定义镜像，通过 <code>Docker</code> 命令去运行镜像，从而达到启动容器的目的。</p><p><code>Dockerfile</code> 是由一行行命令语句组成，并且支持已 <code>#</code> 开头的注释行。</p><p>一般来说，我们可以将 <code>Dockerfile</code> 分为四个部分：</p><ul class="ul-level-0" style="margin:10px 0 10px 20px"><li><strong>基础镜像(父镜像)信息指令 <code>FROM</code></strong></li><li><strong>维护者信息指令 <code>MAINTAINER</code></strong></li><li><strong>镜像操作指令 <code>RUN</code> 、 <code>EVN</code> 、 <code>ADD</code> 和 <code>WORKDIR</code> 等</strong></li><li><strong>容器启动指令 <code>CMD</code> 、 <code>ENTRYPOINT</code> 和 <code>USER</code> 等</strong></li></ul><p>下面是一段简单的Dockerfile的例子：</p><pre class="prism-token token language-javascript">FROM python:2.7MAINTAINER Angel_Kitty &lt;angelkitty6698@gmail.com&gt;COPY . /appWORKDIR /appRUN pip install -r requirements.txtEXPOSE 5000ENTRYPOINT [&quot;python&quot;]CMD [&quot;app.py&quot;]</pre><p>我们可以分析一下上面这个过程：</p><ul class="ul-level-0" style="margin:10px 0 10px 20px"><li>1、从 <code>Docker Hub</code> 上 <code>pull</code> 下 <code>python 2.7</code> 的基础镜像</li><li>2、显示维护者的信息</li><li>3、<code>copy</code> 当前目录到容器中的 <code>/app</code> 目录下 复制本地主机的 <code>&lt;src&gt;</code> ( <code>Dockerfile</code> 所在目录的相对路径)到容器里 <code>&lt;dest&gt;</code></li><li>4、指定工作路径为 <code>/app</code></li><li>5、安装依赖包</li><li>6、暴露 <code>5000</code> 端口</li><li>7、启动 <code>app</code></li></ul><p>这个例子是启动一个 <code>python flask app</code> 的 <code>Dockerfile</code> ( <code>flask</code> 是 <code>python</code> 的一个轻量的 <code>web</code> 框架)，相信大家从这个例子中能够稍微理解了Dockfile的组成以及指令的编写过程。</p><h3>Dockerfile常用的指令</h3><p>根据上面的例子，我们已经差不多知道了Dockerfile的组成以及指令的编写过程，我们再来理解一下这些常用命令就会得心应手了。</p><p>由于 <code>Dockerfile</code> 中所有的命令都是以下格式：<code>INSTRUCTION argument</code> ，指令 <code>(INSTRUCTION)</code> 不分大小写，但是推荐大写，和sql语句是不是很相似呢？下面我们正式来讲解一下这些指令集吧。</p><h4>FROM</h4><p><code>FROM</code> 是用于指定基础的 <code>images</code> ，一般格式为 <code>FROM &lt;image&gt;</code> or <code>FORM &lt;image&gt;:&lt;tag&gt;</code> ，所有的 <code>Dockerfile</code> 都用该以 <code>FROM</code> 开头，<code>FROM</code> 命令指明 <code>Dockerfile</code> 所创建的镜像文件以什么镜像为基础，<code>FROM</code> 以后的所有指令都会在 <code>FROM</code> 的基础上进行创建镜像。可以在同一个 <code>Dockerfile</code> 中多次使用 <code>FROM</code> 命令用于创建多个镜像。比如我们要指定 <code>python 2.7</code> 的基础镜像，我们可以像如下写法一样：</p><pre class="prism-token token language-javascript">FROM python:2.7</pre><h4>MAINTAINER</h4><p>MAINTAINER 是用于指定镜像创建者和联系方式，一般格式为 <code>MAINTAINER &lt;name&gt;</code> 。这里我设置成我的 <code>ID</code> 和邮箱：</p><pre class="prism-token token language-javascript">MAINTAINER Angel_Kitty &lt;angelkitty6698@gmail.com&gt;</pre><h4>COPY</h4><p><code>COPY</code> 是用于复制本地主机的 <code>&lt;src&gt;</code> (为 Dockerfile 所在目录的相对路径)到容器中的 <code>&lt;dest&gt;</code>。</p><p>当使用本地目录为源目录时，推荐使用 <code>COPY</code> 。一般格式为 <code>COPY &lt;src&gt;&lt;dest&gt;</code> 。例如我们要拷贝当前目录到容器中的 <code>/app</code> 目录下，我们可以这样操作：</p><pre class="prism-token token language-javascript">COPY . /app</pre><h4>WORKDIR</h4><p><code>WORKDIR</code> 用于配合 <code>RUN</code>，<code>CMD</code>，<code>ENTRYPOINT</code> 命令设置当前工作路径。可以设置多次，如果是相对路径，则相对前一个 <code>WORKDIR</code> 命令。默认路径为<code>/</code>。一般格式为 <code>WORKDIR /path/to/work/dir</code> 。例如我们设置<code>/app</code> 路径，我们可以进行如下操作：</p><pre class="prism-token token language-javascript">WORKDIR /app</pre><h4>RUN</h4><p><code>RUN</code> 用于容器内部执行命令。每个 <code>RUN</code> 命令相当于在原有的镜像基础上添加了一个改动层，原有的镜像不会有变化。一般格式为 <code>RUN &lt;command&gt;</code> 。例如我们要安装 <code>python</code> 依赖包，我们做法如下：</p><pre class="prism-token token language-javascript">RUN pip install -r requirements.txt</pre><h4>EXPOSE</h4><p><code>EXPOSE</code> 命令用来指定对外开放的端口。一般格式为 <code>EXPOSE &lt;port&gt; [&lt;port&gt;...]</code></p><p>例如上面那个例子，开放5000端口：</p><pre class="prism-token token language-javascript">EXPOSE 5000</pre><h4>ENTRYPOINT</h4><p><code>ENTRYPOINT</code> 可以让你的容器表现得像一个可执行程序一样。一个 <code>Dockerfile</code> 中只能有一个 <code>ENTRYPOINT</code>，如果有多个，则最后一个生效。</p><p><code>ENTRYPOINT</code> 命令也有两种格式：</p><ul class="ul-level-0" style="margin:10px 0 10px 20px"><li><code>ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code> ：推荐使用的 <code>exec</code>形式</li><li><code>ENTRYPOINT command param1 param2</code> ：<code>shell</code> 形式</li></ul><p>例如下面这个，我们要将 <code>python</code> 镜像变成可执行的程序，我们可以这样去做：</p><pre class="prism-token token language-javascript">ENTRYPOINT [&quot;python&quot;]</pre><h4>CMD</h4><p><code>CMD</code> 命令用于启动容器时默认执行的命令，<code>CMD</code> 命令可以包含可执行文件，也可以不包含可执行文件。不包含可执行文件的情况下就要用 <code>ENTRYPOINT</code> 指定一个，然后 <code>CMD</code> 命令的参数就会作为<code>ENTRYPOINT</code>的参数。</p><p><code>CMD</code> 命令有三种格式：</p><ul class="ul-level-0" style="margin:10px 0 10px 20px"><li><code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code>：推荐使用的 <code>exec</code> 形式。</li><li><code>CMD [&quot;param1&quot;,&quot;param2&quot;]</code>：无可执行程序形式</li><li><code>CMD command param1 param2</code>：shell 形式。</li></ul><p>一个 <code>Dockerfile</code> 中只能有一个<code>CMD</code>，如果有多个，则最后一个生效。而 <code>CMD</code> 的 <code>shell</code> 形式默认调用 <code>/bin/sh -c</code> 执行命令。</p><p><code>CMD</code> 命令会被 <code>Docker</code> 命令行传入的参数覆盖：<code>docker run busybox /bin/echo Hello</code> <code>Docker</code> 会把 <code>CMD</code> 里的命令覆盖。</p><p>例如我们要启动 <code>/app</code> ，我们可以用如下命令实现：</p><pre class="prism-token token language-javascript">CMD [&quot;app.py&quot;]</pre><p>当然还有一些其他的命令，我们在用到的时候再去一一讲解一下。</p><h3>构建Dockerfile</h3><p>我们大体已经把Dockerfile的写法讲述完毕，我们可以自己动手写一个例子：</p><pre class="prism-token token language-javascript">mkdir static_webcd static_webtouch Dockerfile然后 vi Dockerfile  开始编辑该文件输入 i 开始编辑<p>以下是我们构建的Dockerfile内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">MAINTAINER Angel_Kitty &amp;lt;angelkitty6698@gmail.com&amp;gt;</span><br><span class="line">RUN echo &amp;#x27;&amp;lt;h1&amp;gt;Hello, Docker!&amp;lt;/h1&amp;gt;&amp;#x27; &amp;gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure><p>编辑完后 按 esc 退出编辑<br>然后  :wq    写入 退出</p></pre><p>我们在 <code>Dockerfile</code> 文件所在目录执行：</p><pre class="prism-token token language-javascript">docker build -t angelkitty/nginx_web:v1 .</pre><p>我们解释一下， <code>-t</code> 是为新镜像设置仓库和名称，其中 <code>angelkitty</code> 为仓库名， <code>nginx_web</code> 为镜像名， <code>:v1</code> 为标签（不添加为默认 <code>latest</code> ）</p><p>我们构建完成之后，使用 <code>docker images</code> 命令查看所有镜像，如果存在 <code>REPOSITORY</code> 为 <code>nginx</code> 和 <code>TAG</code> 是 <code>v1</code> 的信息，就表示构建成功。</p><figure><div class="image-block"><span class="lazy-image-holder" dataurl="https://ask.qcloudimg.com/http-save/yehe-1564476/dk3em8ed3u.png"></span></div></figure><p>接下来使用 <code>docker run</code> 命令来启动容器</p><pre class="prism-token token language-javascript">docker run --name nginx_web -d -p 8080:80   angelkitty/nginx_web:v1</pre><p>这条命令会用 nginx 镜像启动一个容器，命名为 <code>nginx_web</code> ，并且映射了 8080 端口，这样我们可以用浏览器去访问这个 <code>nginx</code> 服务器：<code><a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a></code> 或者 http://本机的IP地址:8080/，页面返回信息：</p><figure><div class="image-block"><span class="lazy-image-holder" dataurl="https://ask.qcloudimg.com/http-save/yehe-1564476/vly9qi8jsc.png"></span></div></figure><p>这样一个简单使用 <code>Dockerfile</code> 构建镜像，运行容器的示例就完成了！</p><p></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="experience" scheme="https://eliasliangyu.github.io/tags/experience/"/>
    
  </entry>
  
  <entry>
    <title>三种云的区别</title>
    <link href="https://eliasliangyu.github.io/2019/06/25/%E4%B8%89%E7%A7%8D%E4%BA%91%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://eliasliangyu.github.io/2019/06/25/三种云的区别/</id>
    <published>2019-06-25T11:15:20.000Z</published>
    <updated>2019-06-25T12:19:30.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>公有云</h1><p>公有云通常指第三方提供商用户能够使使用的云，公有云一般可通过 Internet 使用，可能是免费或成本低廉的。这种云有许多实例，可在当今整个开放的公有网络中提供服务。公有云的最大意义是能够以低廉的价格，提供有吸引力的服务给最终用户，创造新的业务价值，公有云作为一个支撑平台，还能够整合上游的服务（如增值业务，广告）提供者和下游最终用户，打造新的价值链和生态系统。它使客户能够访问和共享基本的计算机基础设施，其中包括硬件、存储和带宽等资源。</p><p><strong>优点：</strong>除了通过网络提供服务外，客户只需为他们使用的资源支付电用。此外，由于组织可以访问服务提供商的云计算基础设施，因此他们无需担心自己安装和维护的问题。</p><p><strong>缺点：</strong>与安全有关。公共云通常不能满足许多安全法规遵从性要求，因为不同的服务器驻留在多个国家，并具有各种安全法规。而且，网络问题可能发生在在线流量峰值期间。虽然公共云模型通过提供按需付费的定价方式通常具有成本效益，但在移动大量数据时，其费用会迅速增加。</p><p><img src="//eliasliangyu.github.io/2019/06/25/三种云的区别/cloud.jpeg" alt></p><p></p><h1>私有云</h1><p>私有云(Private Clouds)是为一个客户单独使用而构建的，因而提供对数据、安全性和服务质量的最有效控制。该公司拥有基础设施，并可以控制在此基础设施上部署应用程序的方式。私有云可部署在企业数据中心的防火墙内，也可以将它们部署在一个安全的主机托管场所。私有云极大的保障了安全问题，目前有些企业已经开始构建自己的私有云。</p><p><strong>优点：</strong>提供了更高的安全性，因为单个公司是唯一可以访问它的指定实体。这也使组织更容易定制其资源以满足特定的IT要求。</p><p><strong>缺点：</strong>安装成本很高。此外，企业仅限于合同中规定的云计算基础设施资源。私有云的高度安全性可能会使得从远程位置访问也变得很困难。</p><h1>混合云</h1><p>混合云是公有云和私有云两种服务方式的结合。由于安全和控制原因，并非所有的企业信息都能放置在公有云上，这样大部分已经应用云计算的企业将会使用混合云模式。很多将选择同时使用公有云和私有云，有一些也会同时建立公众云。因为公有云只会向用户使用的资源收费，所以集中云将会变成处理需求高峰的一个非常便宜的方式。比如对一些零售商来说，他们的操作需求会随着假日的到来而剧增，或者是有些业务会有季节性的上扬。同时混合云也为其他目的的弹性需求提供了一个很好的基础，比如，灾难恢复。这意味着私有云把公有云作为灾难转移的平台，并在需要的时候去使用它。这是一个极具成本效应的理念。另一个好的理念是，使用公有云作为一个选择性的平台，同时选择其他的公有云作为灾难转移平台。</p><p><strong>优点：</strong>允许用户利用公共云和私有云的优势。还为应用程序在多云环境中的移动提供了极大的灵活性。此外，混合云模式具有成本效益，因为企业可以根据需要决定使用成本更昂贵的云计算资源。</p><p><strong>缺点：</strong>因为设置更加复杂而难以维护和保护。此外，由于混合云是不同的云平台、数据和应用程序的组合，因此整合可能是一项挑战。在开发混合云时，基础设施之间也会出现主要的兼容性问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="experience" scheme="https://eliasliangyu.github.io/tags/experience/"/>
    
  </entry>
  
  <entry>
    <title>OpenStack架构知识梳理</title>
    <link href="https://eliasliangyu.github.io/2019/06/25/OpenStack%E6%9E%B6%E6%9E%84%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
    <id>https://eliasliangyu.github.io/2019/06/25/OpenStack架构知识梳理/</id>
    <published>2019-06-25T10:36:30.000Z</published>
    <updated>2019-06-25T12:27:04.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>OpenStack既是一个社区，也是一个项目和一个开源软件，提供开放源码软件，建立公共和私有云，它提供了一个部署云的操作平台或工具集，其宗旨在于：帮助组织运行为虚拟计算或存储服务的云，为公有云、私有云，也为大云、小云提供可扩展的、灵活的云计算。<br data-filtered="filtered">OpenStackd开源项目由社区维护，包括OpenStack计算（代号为Nova），OpenStack对象存储（代号为Swift），并OpenStack镜像服务（代号Glance）的集合。 OpenStack提供了一个操作平台，或工具包，用于编排云。</p><p>下面列出Openstack的详细构架图</p><p><img src="https://images2015.cnblogs.com/blog/907596/201608/907596-20160803154744809-483681990.png" alt></p><p>Openstack的网络拓扑结构图</p><p><img src="https://images2015.cnblogs.com/blog/907596/201608/907596-20160803154957606-291369411.png" alt></p><p>整个OpenStack是由控制节点，计算节点，网络节点，存储节点四大部分组成。（这四个节点也可以安装在一台机器上，单机部署）<br data-filtered="filtered">其中：<br data-filtered="filtered">控制节点负责对其余节点的控制，包含虚拟机建立，迁移，网络分配，存储分配等等<br data-filtered="filtered">计算节点负责虚拟机运行<br data-filtered="filtered">网络节点负责对外网络与内网络之间的通信<br data-filtered="filtered">存储节点负责对虚拟机的额外存储管理等等</p><p></p><h1>控制节点架构：</h1><p>控制节点包括以下服务</p><p>&nbsp; &nbsp;管理支持服务</p><p>&nbsp; &nbsp;基础管理服务</p><p>&nbsp; &nbsp;扩展管理服务</p><p>&nbsp; &nbsp;1）管理支持服务包含MySQL与Qpid两个服务</p><p>MySQL：数据库作为基础/扩展服务产生的数据存放的地方</p><p>Qpid：消息代理(也称消息中间件)为其他各种服务之间提供了统一的消息通信服务</p><p>&nbsp; &nbsp;2）基础管理服务包含Keystone，Glance，Nova，Neutron，Horizon五个服务</p><p>Keystone：认证管理服务，提供了其余所有组件的认证信息/令牌的管理，创建，修改等等，使用MySQL作为统一的数据库</p><p>Glance：镜像管理服务，提供了对虚拟机部署的时候所能提供的镜像的管理，包含镜像的导入，格式，以及制作相应的模板</p><p>Nova：计算管理服务，提供了对计算节点的Nova的管理，使用Nova-API进行通信</p><p>Neutron：网络管理服务，提供了对网络节点的网络拓扑管理，同时提供Neutron在Horizon的管理面板</p><p>Horizon：控制台服务，提供了以Web的形式对所有节点的所有服务的管理，通常把该服务称为DashBoard</p><p>&nbsp; &nbsp;3）扩展管理服务包含Cinder，Swift，Trove，Heat，Centimeter五个服务</p><p>Cinder：提供管理存储节点的Cinder相关，同时提供Cinder在Horizon中的管理面板</p><p>Swift：提供管理存储节点的Swift相关，同时提供Swift在Horizon中的管理面板</p><p>Trove：提供管理数据库节点的Trove相关，同时提供Trove在Horizon中的管理面板</p><p>Heat：提供了基于模板来实现云环境中资源的初始化，依赖关系处理，部署等基本操作，也可以解决自动收缩,负载均衡等高级特性。</p><p>Centimeter：提供对物理资源以及虚拟资源的监控，并记录这些数据，对该数据进行分析，在一定条件下触发相应动作</p><p>控制节点一般来说只需要一个网络端口用于通信/管理各个节点</p><h1>网络节点架构</h1><p>网络节点仅包含Neutron服务</p><p>Neutron：负责管理私有网段与公有网段的通信，以及管理虚拟机网络之间的通信/拓扑，管理虚拟机之上的防火等等</p><p>网络节点包含三个网络端口</p><p>eth0：用于与控制节点进行通信</p><p>eth1：用于与除了控制节点之外的计算/存储节点之间的通信</p><p>eth2：用于外部的虚拟机与相应网络之间的通信</p><h1>计算节点架构</h1><p>计算节点包含Nova，Neutron，Telemeter三个服务</p><p>&nbsp; 1）基础服务</p><p>Nova：提供虚拟机的创建，运行，迁移，快照等各种围绕虚拟机的服务，并提供API与控制节点对接，由控制节点下发任务</p><p>Neutron：提供计算节点与网络节点之间的通信服务</p><p>&nbsp; 2）扩展服务</p><p>Telmeter：提供计算节点的监控代理，将虚拟机的情况反馈给控制节点，是Centimeter的代理服务</p><p>计算节点包含最少两个网络端口</p><p>eth0：与控制节点进行通信，受控制节点统一调配</p><p>eth1：与网络节点，存储节点进行通信</p><h1>存储节点架构</h1><p>存储节点包含Cinder，Swift等服务</p><p>Cinder：块存储服务，提供相应的块存储，简单来说，就是虚拟出一块磁盘，可以挂载到相应的虚拟机之上，不受文件系统等因素影响，对虚拟机来说，这个操作就像是新加了一块硬盘，可以完成对磁盘的任何操作，包括挂载，卸载，格式化，转换文件系统等等操作，大多应用于虚拟机空间不足的情况下的空间扩容等等</p><p>Swift：对象存储服务，提供相应的对象存储，简单来说，就是虚拟出一块磁盘空间，可以在这个空间当中存放文件，也仅仅只能存放文件，不能进行格式化，转换文件系统，大多应用于云磁盘/文件</p><p>存储节点包含最少两个网络接口</p><p>eth0：与控制节点进行通信，接受控制节点任务，受控制节点统一调配</p><p>eth1：与计算/网络节点进行通信，完成控制节点下发的各类任务</p><p>----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</p><p><strong>下面说一说Openstack的各个组件作用及关系</strong></p><p><strong>Openstack发展至今，总共集成了下面几个组件：</strong></p><p><strong>Nova - 计算服务</strong><br data-filtered="filtered"><strong>Neutron-网络服务</strong><br data-filtered="filtered"><strong>Swift - 对象存储服务</strong><br data-filtered="filtered"><strong>Cinder-块存储服务</strong><br data-filtered="filtered"><strong>Glance - 镜像服务</strong><br data-filtered="filtered"><strong>Keystone - 认证服务</strong><br data-filtered="filtered"><strong>Horizon - UI服务</strong><br data-filtered="filtered"><strong>Ceilometer-监控服务</strong><br data-filtered="filtered"><strong>Heat-集群服务</strong><br data-filtered="filtered"><strong>Trove-数据库服务</strong></p><p>组件间的关系图如下：</p><p><img src="https://images2015.cnblogs.com/blog/907596/201608/907596-20160803161818153-400482667.png" alt></p><h1>重要组件介绍</h1><h2><strong>OpenStack认证服务（Keystone）</strong></h2><br data-filtered="filtered">Keystone为所有的OpenStack组件提供认证和访问策略服务，它依赖自身REST（基于Identity API）系统进行工作，主要对（但不限于）Swift、Glance、Nova等进行认证与授权。事实上，授权通过对动作消息来源者请求的合法性进行鉴定。下图显示了身份认证服务流程：<p></p><p><img src="https://images2015.cnblogs.com/blog/907596/201608/907596-20160803162042356-1138315067.png" alt></p><p>&nbsp;</p><p>Keystone采用两种授权方式，一种基于<strong>用户名/密码</strong>，另一种<strong>基于令牌（Token）</strong>。</p><p>除此之外，Keystone提供以下三种服务：<br data-filtered="filtered">&nbsp; &nbsp; 令牌服务：含有授权用户的授权信息<br data-filtered="filtered">&nbsp; &nbsp; 目录服务：含有用户合法操作的可用服务列表<br data-filtered="filtered">&nbsp; &nbsp; 策略服务：利用Keystone具体指定用户或群组某些访问权限</p><h2>keystone认证服务注意点：</h2><p>服务入口：如Nova、Swift和Glance一样每个OpenStack服务都拥有一个指定的端口和专属的URL，我们称其为入口（endpoints）。</p><p>区位：在某个数据中心，一个区位具体指定了一处物理位置。在典型的云架构中，如果不是所有的服务都访问分布式数据中心或服务器的话，则也称其为区位。</p><p>用户：Keystone授权使用者<br data-filtered="filtered">　　PS：代表一个个体，OpenStack以用户的形式来授权服务给它们。用户拥有证书（credentials），且可能分配给一个或多个租户。经过验证后，会为每个单独的租户提供一个特定的令牌。</p><p>服务：总体而言，任何通过Keystone进行连接或管理的组件都被称为服务。举个例子，我们可以称Glance为Keystone的服务。</p><p>角色：为了维护安全限定，就云内特定用户可执行的操作而言，该用户关联的角色是非常重要的。<br data-filtered="filtered">　　PS：一个角色是应用于某个租户的使用权限集合，以允许某个指定用户访问或使用特定操作。角色是使用权限的逻辑分组，它使得通用的权限可以简单地分组并绑定到与某个指定租户相关的用户。</p><p>租间：租间指的是具有全部服务入口并配有特定成员角色的一个项目。<br data-filtered="filtered">　　PS：一个租间映射到一个Nova的&ldquo;project-id&rdquo;，在对象存储中，一个租间可以有多个容器。根据不同的安装方式，一个租间可以代表一个客户、帐号、组织或项目。</p><h2>OpenStack计算设施----Nova</h2><p>Nova是OpenStack计算的弹性控制器。OpenStack云实例生命期所需的各种动作都将由Nova进行处理和支撑，这就意味着Nova以管理平台的身份登场，负责管理整个云的计算资源、网络、授权及测度。虽然Nova本身并不提供任何虚拟能力，但是它将使用libvirt API与虚拟机的宿主机进行交互。Nova通过Web服务API来对外提供处理接口，而且这些接口与Amazon的Web服务接口是兼容的。</p><p>功能及特点：　<br data-filtered="filtered">实例生命周期管理<br data-filtered="filtered">计算资源管理<br data-filtered="filtered">网络与授权管理<br data-filtered="filtered">基于REST的API<br data-filtered="filtered">异步连续通信<br data-filtered="filtered">支持各种宿主：Xen、XenServer/XCP、KVM、UML、VMware vSphere及Hyper-V</p><p>Nova弹性云（OpenStack计算部件）包含以下主要部分：<br data-filtered="filtered">API Server（nova-api）<br data-filtered="filtered">消息队列（rabbit-mq server）<br data-filtered="filtered">运算工作站（nova-compute）<br data-filtered="filtered">网络控制器（nova-network）<br data-filtered="filtered">卷管理（nova-volume）<br data-filtered="filtered">调度器（nova-scheduler）</p><p>解释如下：<br data-filtered="filtered">1）API服务器（nova-api）<br data-filtered="filtered">API服务器提供了云设施与外界交互的接口，它是外界用户对云实施管理的唯一通道。通过使用web服务来调用各种EC2的API，接着API服务器便通过消息队列把请求送达至云内目标设施进行处理。作为对EC2-api的替代，用户也可以使用OpenStack的原生API，我们把它叫做&ldquo;OpenStack API&rdquo;。</p><p>2）消息队列（Rabbit MQ Server）<br data-filtered="filtered">OpenStack内部在遵循AMQP（高级消息队列协议）的基础上采用消息队列进行通信。Nova对请求应答进行异步调用，当请求接收后便则立即触发一个回调。由于使用了异步通信，不会有用户的动作被长置于等待状态。例如，启动一个实例或上传一份镜像的过程较为耗时，API调用就将等待返回结果而不影响其它操作，在此异步通信起到了很大作用，使整个系统变得更加高效。</p><p>　3）调度器（nova-scheduler）　　</p><p>调度器负责把nova-API调用送达给目标。调度器以名为&ldquo;nova-schedule&rdquo;的守护进程方式运行，并根据调度算法从可用资源池中恰当地选择运算服务器。有很多因素都可以影响调度结果，比如负载、内存、子节点的远近、CPU架构等等。强大的是nova调度器采用的是可插入式架构。</p><p>目前nova调度器使用了几种基本的调度算法：<br data-filtered="filtered">　　随机化：主机随机选择可用节点；<br data-filtered="filtered">　　可用化：与随机相似，只是随机选择的范围被指定；<br data-filtered="filtered">　　简单化：应用这种方式，主机选择负载最小者来运行实例。负载数据可以从别处获得，如负载均衡服务器。</p><p>4）运算工作站（nova-compute）<br data-filtered="filtered">运算工作站的主要任务是管理实例的整个生命周期。他们通过消息队列接收请求并执行，从而对实例进行各种操作。在典型实际生产环境下，会架设许多运算工作站，根据调度算法，一个实例可以在可用的任意一台运算工作站上部署。</p><p>　5）网络控制器（nova-network）<br data-filtered="filtered">网络控制器处理主机的网络配置，例如IP地址分配，配置项目VLAN，设定安全群组以及为计算节点配置网络。</p><p>　6）卷工作站（nova-volume）　<br data-filtered="filtered">卷工作站管理基于LVM的 实例卷，它能够为一个实例创建、删除、附加卷，也可以从一个实例中分离卷。卷管理为何如此重要？因为它提供了一种保持实例持续存储的手段，比如当结束一个 实例后，根分区如果是非持续化的，那么对其的任何改变都将丢失。可是，如果从一个实例中将卷分离出来，或者为这个实例附加上卷的话，即使实例被关闭，数据 仍然保存其中。这些数据可以通过将卷附加到原实例或其他实例的方式而重新访问。</p><p>因此，为了日后访问，重要数据务必要写入卷中。这种应用对于数据服务器实例的存储而言，尤为重要。</p><h2>OpenStack镜像服务器----Glance</h2><p>OpenStack镜像服务器是一套虚拟机镜像发现、注册、检索系统，我们可以将镜像存储到以下任意一种存储中：<br data-filtered="filtered">本地文件系统（默认）<br data-filtered="filtered">S3直接存储<br data-filtered="filtered">S3对象存储（作为S3访问的中间渠道）<br data-filtered="filtered">OpenStack对象存储等等。<br data-filtered="filtered">　　<br data-filtered="filtered">功能及特点：<br data-filtered="filtered">提供镜像相关服务。</p><p>Glance构件：<br data-filtered="filtered">1）Glance-API：<br data-filtered="filtered">　 主要负责接收响应镜像管理命令的Restful请求，分析消息请求信息并分发其所带的命令（如新增，删除，更新等）。默认绑定端口是9292。<br data-filtered="filtered">2）Glance-Registry：<br data-filtered="filtered">　　主要负责接收响应镜像元数据命令的Restful请求。分析消息请求信息并分发其所带的命令（如获取元数据，更新元数据等）。默认绑定的端口是9191。</p><h2>OpenStack存储设施----Swift</h2><p>Swift为OpenStack提供一种分布式、持续虚拟对象存储，它类似于Amazon Web Service的S3简单存储服务。Swift具有跨节点百级对象的存储能力。Swift内建冗余和失效备援管理，也能够处理归档和媒体流，特别是对大数据（千兆字节）和大容量（多对象数量）的测度非常高效。</p><p>swift功能及特点：　　<br data-filtered="filtered">海量对象存储<br data-filtered="filtered">大文件（对象）存储<br data-filtered="filtered">数据冗余管理<br data-filtered="filtered">归档能力-----处理大数据集<br data-filtered="filtered">为虚拟机和云应用提供数据容器<br data-filtered="filtered">处理流媒体<br data-filtered="filtered">对象安全存储<br data-filtered="filtered">备份与归档<br data-filtered="filtered">良好的可伸缩性</p><p>Swift组件<br data-filtered="filtered">Swift账户<br data-filtered="filtered">Swift容器<br data-filtered="filtered">Swift对象<br data-filtered="filtered">Swift代理<br data-filtered="filtered">Swift RING<br data-filtered="filtered">　　<br data-filtered="filtered">Swift代理服务器　　<br data-filtered="filtered">用户都是通过Swift-API与代理服务器进行交互，代理服务器正是接收外界请求的门卫，它检测合法的实体位置并路由它们的请求。<br data-filtered="filtered">此外，代理服务器也同时处理实体失效而转移时，故障切换的实体重复路由请求。</p><p>Swift对象服务器<br data-filtered="filtered">对象服务器是一种二进制存储，它负责处理本地存储中的对象数据的存储、检索和删除。对象都是文件系统中存放的典型的二进制文件，具有扩展文件属性的元数据（xattr）。</p><p>注意：xattr格式被Linux中的ext3/4，XFS，Btrfs，JFS和ReiserFS所支持，但是并没有有效测试证明在XFS，JFS，ReiserFS，Reiser4和ZFS下也同样能运行良好。不过，XFS被认为是当前最好的选择。</p><p>Swift容器服务器<br data-filtered="filtered">容器服务器将列出一个容器中的所有对象，默认对象列表将存储为SQLite文件（译者注：也可以修改为MySQL，安装中就是以MySQL为例）。容器服务器也会统计容器中包含的对象数量及容器的存储空间耗费。</p><p>Swift账户服务器<br data-filtered="filtered">账户服务器与容器服务器类似，将列出容器中的对象。</p><p>Ring（索引环）</p><p>Ring容器记录着Swift中物理存储对象的位置信息，它是真实物理存储位置的实体名的虚拟映射，类似于查找及定位不同集群的实体真实物理位置的索引服务。这里所谓的实体指账户、容器、对象，它们都拥有属于自己的不同的Rings。</p><h2>OpenStack管理的Web接口----Horizon</h2><p>Horizon是一个用以管理、控制OpenStack服务的Web控制面板，它可以管理实例、镜像、创建密匙对，对实例添加卷、操作Swift容器等。除此之外，用户还可以在控制面板中使用终端（console）或VNC直接访问实例。</p><p>总之，Horizon具有如下一些特点：　　<br data-filtered="filtered">实例管理：创建、终止实例，查看终端日志，VNC连接，添加卷等<br data-filtered="filtered">访问与安全管理：创建安全群组，管理密匙对，设置浮动IP等<br data-filtered="filtered">偏好设定：对虚拟硬件模板可以进行不同偏好设定<br data-filtered="filtered">镜像管理：编辑或删除镜像<br data-filtered="filtered">查看服务目录<br data-filtered="filtered">管理用户、配额及项目用途<br data-filtered="filtered">用户管理：创建用户等<br data-filtered="filtered">卷管理：创建卷和快照<br data-filtered="filtered">对象存储处理：创建、删除容器和对象<br data-filtered="filtered">为项目下载环境变量</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="experience" scheme="https://eliasliangyu.github.io/tags/experience/"/>
    
  </entry>
  
  <entry>
    <title>Chrome扩展推荐</title>
    <link href="https://eliasliangyu.github.io/2019/06/19/Chrome%E6%89%A9%E5%B1%95%E6%8E%A8%E8%8D%90/"/>
    <id>https://eliasliangyu.github.io/2019/06/19/Chrome扩展推荐/</id>
    <published>2019-06-19T14:30:52.000Z</published>
    <updated>2019-06-19T14:40:53.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><b><a href="https://sspai.com/post/55164" target="_blank" rel="noopener">——/转载自少数派sspai.com/——</a><b></b></b></p><div><h2 id="ss-H2-1560310385817">让网页焕新颜</h2><p>浏览器的本职工作，当然是访问网页。不过，总有一些网站的设计让我们心生不快：铺天盖地的广告、陈旧过时的 UI、繁复难用的交互……而本节介绍的 8 款扩展，就能解决这些问题。</p><h3 id="ss-H3-1560310388077">Stylus</h3><p>Stylus 是一款基于知名网页美化工具 Stylish 1.5.2 版本开发的开源扩展，允许你通过编辑 CSS 为网页创建自定义样式、主题等。安装后，Stylus 便会智能提示适用于当前网站的用户样式，可以轻松安装使用。如果你略懂编程，还可以自己修改或创建样式，将网页调教为自己喜欢的模样。</p><figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_713147/15602229401508.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="Stylus 样式管理" data-original="https://cdn.sspai.com/editor/u_713147/15602229401508.png"><figcaption class="ss-image-caption">Stylus 样式管理</figcaption></figure>￼<figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_713147/15602229401522.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="Stylus 样式详情" data-original="https://cdn.sspai.com/editor/u_713147/15602229401522.png"><figcaption class="ss-image-caption">Stylus 样式详情</figcaption></figure>￼<figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_713147/15602229401535.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="「百度轻」样式效果预览" data-original="https://cdn.sspai.com/editor/u_713147/15602229401535.gif"><figcaption class="ss-image-caption">「百度轻」样式效果预览</figcaption></figure>￼<p>你可以在 <a href="https://chrome.google.com/webstore/detail/stylus/clngdbkpkpeebahjckkjfobafhncgmne" target="_blank" rel="noopener">Chrome 网上应用店</a> 和 <a href="https://addons.mozilla.org/zh-CN/firefox/addon/styl-us/" target="_blank" rel="noopener">Firefox Add-ons</a> 免费获取 Stylus。</p><p>P.S. 如果你正在使用 Stylish，其已被原开发者出售，曾被曝光后台窃取用户隐私数据，建议卸载。Stylus 则基于由原作者维护的最后一个版本，并删除了所有追踪功能，更好地保护隐私。</p><p><strong>关联阅读：</strong><a href="https://sspai.com/post/45537" target="_blank" rel="noopener">这款网页美化扩展跟 Stylish 一样好用，但它不会偷看你的浏览历史：Stylus</a></p><h3 id="ss-H3-1560310392539">简悦</h3><p>尽管 Chrome 75 已经为我们带来了原生的阅读模式，但其仍有诸多不足：入口深、选项少、适配差……简悦则完美解决了这些问题，它手动适配了数百个常用网站，支持颜色主题、字体、间距等多种样式切换。对于未适配的网站，简悦还提供了临时聚焦模式，帮助你只关注内容，不受其它元素干扰。</p><figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_713147/15602229401549.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="阅读模式效果" data-original="https://cdn.sspai.com/editor/u_713147/15602229401549.gif"><figcaption class="ss-image-caption">阅读模式效果</figcaption></figure>￼<p>简悦更强大的地方，在于丰富的动作和插件支持。你可以将网页内容一键分享至微博、Twitter，也可以发送至印象笔记、Pocket 暂存，或者干脆直接推送至 Kindle 继续阅读。还是没有你想要的功能？简悦支持安装第三方插件，实现无图模式、划词搜索、全文翻译等更多特性，等你发掘。</p><figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_713147/15602229401562.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="简悦分享动作" data-original="https://cdn.sspai.com/editor/u_713147/15602229401562.png"><figcaption class="ss-image-caption">简悦分享动作</figcaption></figure>￼<figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_713147/15602229401576.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="简悦插件中心" data-original="https://cdn.sspai.com/editor/u_713147/15602229401576.png"><figcaption class="ss-image-caption">简悦插件中心</figcaption></figure>￼<p>你可以在 <a href="http://ksria.com/simpread/" target="_blank" rel="noopener">官网</a>、<a href="https://chrome.google.com/webstore/detail/simpread-reader-view/ijllcpnolfcooahcekpamkbidhejabll" target="_blank" rel="noopener">Chrome 网上应用店</a> 和 <a href="https://addons.mozilla.org/zh-CN/firefox/addon/simpread/" target="_blank" rel="noopener">Firefox Add-ons</a> 免费获取简悦。</p><p><strong>关联阅读：</strong><br></p><ul><li><a href="https://sspai.com/post/39491" target="_blank" rel="noopener">为了完美阅读模式这个小目标 ，我适配了 160+ 个网站，因此诞生了它 - 简悦</a></li><li><a href="https://sspai.com/post/52492" target="_blank" rel="noopener">不只是「完美」阅读模式，他想用这款阅读工具帮你更好获取知识：专访简悦 | 幕后</a></li></ul><h3 id="toc_3--NaN">Dark Reader</h3><p>继 macOS Mojave 后，刚亮相的 iOS 13 也为我们带来了原生的黑暗模式。如果你希望在全平台获得一致的浏览体验，Dark Reader 就能帮上忙。它可以智能反转网页主体颜色，保证图片辨识度的情况下将背景设为深色，呵护眼部。在设置中，你还可以手动调整颜色、对比度、滤镜等。如果你是高级玩家，还可以在开发者工具中直接编写 CSS，可玩性极高。</p><figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_713147/15602229401591.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="开启前后对比" data-original="https://cdn.sspai.com/editor/u_713147/15602229401591.jpg"><figcaption class="ss-image-caption">开启前后对比</figcaption></figure>￼<figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_713147/15602229401603.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="自定义样式" data-original="https://cdn.sspai.com/editor/u_713147/15602229401603.png"><figcaption class="ss-image-caption">自定义样式</figcaption></figure>￼<p>你可以在 <a href="https://chrome.google.com/webstore/detail/dark-reader/eimadpbcbfnmbkopoojfekhnkhdbieeh" target="_blank" rel="noopener">Chrome 网上应用店</a> 和 <a href="https://addons.mozilla.org/en-US/firefox/addon/darkreader/" target="_blank" rel="noopener">Firefox Add-ons</a> 免费获取 Dark Reader。</p><h3 id="toc_4--NaN">uBlock Origin</h3><p>uBlock Origin 是一款极其强大的广告屏蔽和反追踪扩展，与更广为人知的 AdBlock Plus 相比，它仅默认加载匹配当前网页的规则，因此性能更强、占用资源更低。你可以直接添加由他人维护的广告屏蔽规则列表，或者通过元素拾取器准确屏蔽不想看到的部分，也可以为想要支持的网站（例：sspai.com）启用白名单，方法多样。</p><figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_713147/15602229401615.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt data-original="https://cdn.sspai.com/editor/u_713147/15602229401615.png"></figure>￼<figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_713147/15602229401626.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="元素拾取器" data-original="https://cdn.sspai.com/editor/u_713147/15602229401626.png"><figcaption class="ss-image-caption">元素拾取器</figcaption></figure>￼<p>你可以在 <a href="https://chrome.google.com/webstore/detail/ublock-origin/cjpalhdlnbpafiamejdnhcphjbkeiagm" target="_blank" rel="noopener">Chrome 网上应用店</a> 和 <a href="https://addons.mozilla.org/en-US/firefox/addon/ublock-origin/" target="_blank" rel="noopener">Firefox Add-ons</a> 免费获取 uBlock Origin。</p><h3 id="toc_5--NaN">哔哩哔哩助手</h3><p>哔哩哔哩助手可能是资历最老的 B 站辅助扩展之一，时至今日，已经拥有了关注内容更新推送、画中画、视频下载、自动签到、过滤直播广告等数项涵盖全站板块的功能。此外，你还可以利用哔哩哔哩助手反查具体弹幕发送者，方便屏蔽喷子们。</p><figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_713147/15602229401638.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt data-original="https://cdn.sspai.com/editor/u_713147/15602229401638.png"></figure>￼<p>你可以在 <a href="https://bilibili-helper.github.io/" target="_blank" rel="noopener">官网</a> 或 <a href="https://chrome.google.com/webstore/detail/%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9%E5%8A%A9%E6%89%8B%EF%BC%9Abilibilicom-%E7%BB%BC%E5%90%88%E8%BE%85%E5%8A%A9%E6%89%A9%E5%B1%95/kpbnombpnpcffllnianjibmpadjolanh" target="_blank" rel="noopener">Chrome 网上应用店</a> 免费获取哔哩哔哩助手。</p><h3 id="toc_6--NaN">pakku</h3><p>弹幕可以说是众多 B 站视频的灵魂，但有时，过于密集的弹幕刷屏也会使人心生厌烦，而 Pakku 则可以近乎完美地解决这一问题。启用后，它便会将短时间内集中出现的相似弹幕自动合并为一条，并在后方注明出现次数。在不遮挡画面主要内容的同时，达到欣赏优质弹幕的目的。你还可以调整弹幕合并样式、相似度算法等，或者用正则表达式预先过滤弹幕，自由度较高。</p><figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_713147/15602229401650.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt data-original="https://cdn.sspai.com/editor/u_713147/15602229401650.png"></figure>￼<p>你可以在 <a href="https://s.xmcp.ml/pakkujs/" target="_blank" rel="noopener">官网</a>、<a href="https://chrome.google.com/webstore/detail/jklfcpboamajpiikgkbjcnnnnooefbhh" target="_blank" rel="noopener">Chrome 网上应用店</a> 和 <a href="https://addons.mozilla.org/zh-CN/firefox/addon/pakkujs/?src=external-home" target="_blank" rel="noopener">Firefox Add-ons</a> 免费获取 pakku。</p><h3 id="toc_7--NaN">Simplify Gmail</h3><p>为了完成 KPI，Google 大刀部把广受欢迎的 Inbox 砍掉了，如果你曾是其忠实用户，可能会对陈旧的 Gmail 界面感到不适应。为了拯救你的收件箱，前 Inbox 设计师 Michael Leggett 开发了 Simplify Gmail 扩展，重新设计了按钮和元素的摆放位置，并隐藏了侧边栏，让界面更加清爽干净。</p><figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_713147/15602229401665.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt data-original="https://cdn.sspai.com/editor/u_713147/15602229401665.gif"></figure>￼<p>你可以在 <a href="https://chrome.google.com/webstore/detail/simplify-gmail/pbmlfaiicoikhdbjagjbglnbfcbcojpj" target="_blank" rel="noopener">Chrome 网上应用店</a> 免费获取 Simplify Gmail。</p><h3 id="toc_8--NaN">Augmented Steam</h3><p>一入蒸汽深似海，从此钱包是路人。看着满屏的 -90%，唯有 Augmented Steam 能阻止剁手的冲动。它可以帮助你查看游戏的历史价格、各区售价，隐藏或高亮显示已购买游戏和愿望单项目，在商店页面显示成就、媒体打分和相关文章介绍等，是喜加一前的好帮手。</p><figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_713147/15602229401679.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt data-original="https://cdn.sspai.com/editor/u_713147/15602229401679.png"></figure>￼<figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_713147/15602229401693.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt data-original="https://cdn.sspai.com/editor/u_713147/15602229401693.png"></figure>￼<p>你可以在 <a href="https://chrome.google.com/webstore/detail/dnhpnfgdlenaccegplpojghhmaamnnfp/" target="_blank" rel="noopener">Chrome 网上应用店</a> 和 <a href="https://addons.mozilla.org/en-US/firefox/addon/enhanced-steam-an-itad-fork/" target="_blank" rel="noopener">Firefox Add-ons</a> 免费获取 Augmented Steam。</p><p>P.S. Augmented Steam 基于名气更大的 Enhanced Steam 扩展，但由于后者已停止维护，故推荐此扩展。</p><h2 id="toc_9--NaN">让功能更贴心</h2><p>网页要颜值，更要实用。有的网站精简功能引流 App、有的网站拒不兼容最新标准、还有的网站总是加载出错……要想好好上网，本节推荐的 7 款扩展必不可少。</p><h3 id="toc_10--NaN">Tampermonkey</h3><p>Tampermonkey 是一款 JavaScript 脚本管理器，其与 Stylus 类似，但功能更加强大。从内容屏蔽到样式美化、从功能增强到精简提速，Tampermonkey 脚本几乎无所不能。如果你厌倦了原始网页的诸多不便，不妨试试能否从 <a href="https://greasyfork.org/zh-CN" target="_blank" rel="noopener">Greasy Fork</a> 中找到其他用户编写好的优化脚本，或者干脆自己创建一个，并分享给大家。</p><figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_713147/15602229401708.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="已安装脚本管理" data-original="https://cdn.sspai.com/editor/u_713147/15602229401708.png"><figcaption class="ss-image-caption">已安装脚本管理</figcaption></figure>￼<figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_713147/15602229401722.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="编辑脚本" data-original="https://cdn.sspai.com/editor/u_713147/15602229401722.png"><figcaption class="ss-image-caption" contenteditable="true">编辑脚本</figcaption></figure>￼<figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_713147/15602229401735.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="AC-baidu 和搜索引擎跳转脚本" data-original="https://cdn.sspai.com/editor/u_713147/15602229401735.png"><figcaption class="ss-image-caption">AC-baidu 和搜索引擎跳转脚本</figcaption></figure>￼<p>你可以在 <a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo" target="_blank" rel="noopener">Chrome 网上应用店</a> 和 <a href="https://addons.mozilla.org/en-US/firefox/addon/tampermonkey/" target="_blank" rel="noopener">Firefox Add-ons</a> 免费获取 Tampermonkey。</p><p>关联阅读：<br><a href="https://sspai.com/post/40485" target="_blank" rel="noopener">用 Chrome 的人都需要知道的「神器」扩展：「油猴」使用详解</a><br><a href="https://sspai.com/post/42380" target="_blank" rel="noopener">全方位强化你的浏览器，我们推荐多达 40+ 款实用的油猴脚本</a></p><h3 id="toc_11--NaN">Infinity 新标签页</h3><p>Infinity 也许不是最美观或最实用的新标签页扩展，但很有可能是将两者平衡最优秀的那一个。它内置了上万张风景和插画壁纸，提供 Unsplash、Bing、Life Of Pix 等壁纸源，支持自动切换、遮罩和模糊效果。为了保证 UI 的一致性，Infinity 新标签页重绘了数百个常用网站图标，可以按分类筛选和搜索。你还可以自定义图标布局、形状等，随心定制主界面的显示元素。</p><figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_713147/15602229401753.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt data-original="https://cdn.sspai.com/editor/u_713147/15602229401753.png"></figure>￼<p>你可以在 <a href="https://cn.infinitynewtab.com/" target="_blank" rel="noopener">官网</a>、<a href="https://chrome.google.com/webstore/detail/infinity-new-tab-pro/nnnkddnnlpamobajfibfdgfnbcnkgngh" target="_blank" rel="noopener">Chrome 网上应用店</a> 和 <a href="https://addons.mozilla.org/zh-CN/firefox/addon/infinity-new-tab-pro-firefox" target="_blank" rel="noopener">Firefox Add-ons</a> 免费获取 Infinity 新标签页。</p><h3 id="toc_12--NaN">二管家</h3><p>对于装了 94 个 Chrome 扩展的我来说，如何管理调教它们是件烦心事。而二管家则允许你在一处快速管理所有已安装扩展，通过正则表达式自定义规则，在打开特定网站时自动开启或禁用一组扩展。此外，二管家还能记录所有扩展的安装、卸载等活动记录，并依据云端数据为你推荐适合当前网站的扩展。</p><figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_713147/15602229401769.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt data-original="https://cdn.sspai.com/editor/u_713147/15602229401769.png"></figure>￼<figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_713147/15602229401784.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt data-original="https://cdn.sspai.com/editor/u_713147/15602229401784.png"></figure>￼<p>你可以在 <a href="https://chrome.google.com/webstore/detail/nooboss/aajodjghehmlpahhboidcpfjcncmcklf" target="_blank" rel="noopener">Chrome 网上应用店</a> 免费获取二管家。</p><h3 id="toc_13--NaN">二箱</h3><p>二箱与二管家来自同一位开发者，是一款整合了 Google、百度、必应、TinyEye、SauceNAO 等多个引擎的图片搜索扩展，允许你在一个页面中查看全部相关结果，并按尺寸、相关度等排序。你也可以使用二箱直接截图，或手动上传本地图片搜索，并查看此前的搜索记录。</p><figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_713147/15602229401801.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt data-original="https://cdn.sspai.com/editor/u_713147/15602229401801.png"></figure>￼<p>你可以在 <a href="https://chrome.google.com/webstore/detail/noobox-search-by-image/kidibbfcblfbbafhnlanccjjdehoahep" target="_blank" rel="noopener">Chrome 网上应用店</a> 免费获取二箱。</p><h3 id="toc_14--NaN">IE Tab</h3><p>互联网的辞旧迎新速度愈发迅捷，却总有教务系统和网银页面被甩在身后。如果你不想每次登录网银都要从角落请 Internet Explorer 出山，IE Tab 就是个好选择。它可以在不离开 Chrome 的情况下调用 IE 内核浏览网页，从此告别「不兼容」对话框。</p><figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_713147/15602229401815.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="使用前" data-original="https://cdn.sspai.com/editor/u_713147/15602229401815.png"><figcaption class="ss-image-caption">使用前</figcaption></figure>￼<figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_713147/15602229401831.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="使用后" data-original="https://cdn.sspai.com/editor/u_713147/15602229401831.png"><figcaption class="ss-image-caption">使用后</figcaption></figure>￼<p>你可以在 <a href="https://chrome.google.com/webstore/detail/ie-tab/hehijbfgiekmjfkfjpbkbammjbdenadd" target="_blank" rel="noopener">Chrome 网上应用店</a> 获取 IE Tab，免费版仅支持 Windows，macOS 和 Chrome OS 使用需要订阅高级版。</p><h3 id="toc_15--NaN">Go to Tab</h3><p>一次打开众多网页时，Chrome 就会把所有标签页都缩成一团，完全无法辨识。而 Go to Tab 则可以将当前打开的网页和窗口标题展示为列表，点击即可跳转或关闭。如果标签页实在过多，你还可以用键盘快捷键快速操作，并搜索 URL 和标题，提高浏览效率。</p><figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_713147/15602229401844.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt data-original="https://cdn.sspai.com/editor/u_713147/15602229401844.png"></figure>￼<p>你可以在 <a href="https://chrome.google.com/webstore/detail/go-to-tab/hjfkaobgkmaeomgdhmhhipdbjdhhjkoi" target="_blank" rel="noopener">Chrome 网上应用店</a> 免费获取 Go to Tab。</p><h3 id="toc_16--NaN">AHA Music</h3><p>用浏览器观看视频时，你的注意力可能会被背景音乐所吸引。而 AHA Music 这款扩展就可以自动识别当前正在播放的音乐，并给出 Spotify、YouTube、Deezer 等流媒体服务链接。由于采用了 ACRCloud 作为曲库提供方，AHA Music 基本覆盖了所有时下流行歌曲，让你无后顾之忧。</p><figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_713147/15602229401856.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt data-original="https://cdn.sspai.com/editor/u_713147/15602229401856.gif"></figure>￼<p>你可以在 <a href="https://chrome.google.com/webstore/detail/aha-music-music-identifie/dpacanjfikmhoddligfbehkpomnbgblf" target="_blank" rel="noopener">Chrome 网上应用店</a> 免费获取 AHA Music。</p><h2 id="toc_17--NaN">让工作更高效</h2><p>在少数派写推荐文，必不可少的关键词之一就是「生产力」了。在本文中，我也不能免俗，将为大家介绍 7 款可以加速你的工作效率的 Chrome 扩展，从此告别「996」。</p><h3 id="toc_18--NaN">Toby</h3><p>查询资料时，我们可能会同时打开许多标签页，如果这时突然来了其它紧要工作，只有关闭所有页面下次重新搜索么？有了 Toby，你就可以一键保存当前的标签页组，随时恢复此前的进度。Toby 支持暂存多个标签页组，并通过标签、笔记和备注整理归纳，还能跨设备同步收藏记录。</p><figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_713147/15602229401867.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt data-original="https://cdn.sspai.com/editor/u_713147/15602229401867.png"></figure>￼<p>你可以在 <a href="https://chrome.google.com/webstore/detail/toby-for-chrome/hddnkoipeenegfoeaoibdmnaalmgkpip" target="_blank" rel="noopener">Chrome 网上应用店</a> 免费获取 Toby。</p><p><strong>关联阅读：</strong><a href="https://sspai.com/post/44105" target="_blank" rel="noopener">如何更好地管理「标签页」，我选择 Toby</a></p><h3 id="toc_19--NaN">Spider</h3><p>工作和学习中，你可能会有批量抓取网站内容的需求：商品介绍、新闻标题、表格数据……如果只是单纯的复制粘贴，之后还要费心整理，想要写个爬虫又考验编程水平。这时，不妨试试 Spider，它可以一键抓取网页上的结构化数据，并导出为 JSON 和 CSV 文件，轻松高效。</p><figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_713147/15602229401878.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt data-original="https://cdn.sspai.com/editor/u_713147/15602229401878.gif"></figure>￼<p>你可以在 <a href="https://chrome.google.com/webstore/detail/spider-a-smart-web-scrapi/hhblpocflefpmmfibmajdfcjdkeafpen" target="_blank" rel="noopener">Chrome 网上应用店</a> 免费获取 Spider。</p><h3 id="toc_20--NaN">Forest</h3><p>如果你总是在工作中分心，干正事的时候鼠标却不由自主地点开了摸鱼网站，Forest 就能帮到你。只需设置网站白名单和黑名单，再点击 Forest 的图标，它就会督促你专注于眼前的工作。你可以设置专注时长和树的种类，在结束时收获绿树如荫。如果期间访问了不该上的网站，就只有枯萎的树苗了哦。</p><figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_713147/15602229401890.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt data-original="https://cdn.sspai.com/editor/u_713147/15602229401890.png"></figure>￼<figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_713147/15602229401905.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt data-original="https://cdn.sspai.com/editor/u_713147/15602229401905.png"></figure>￼<p>你可以在 <a href="https://chrome.google.com/webstore/detail/forest-stay-focused-be-pr/kjacjjdnoddnpbbcjilcajfhhbdhkpgk" target="_blank" rel="noopener">Chrome 网上应用店</a> 免费获取 Forest，应用同时提供 <a href="https://itunes.apple.com/app/forest-stay-focused-stop-phubbing/id866450515" target="_blank" rel="noopener">iOS</a> 和 <a href="https://www.coolapk.com/apk/cc.forestapp" target="_blank" rel="noopener">Android</a> 版本。</p><p><strong>关联阅读：</strong><a href="https://sspai.com/post/42393" target="_blank" rel="noopener">你要专心工作，这棵树才能茁壮成长：Forest for Chrome | App+1</a></p><h3 id="toc_21--NaN">WorldBrain&#39;s Memex</h3><p>我们每天都会访问数不清的网站，却很少归纳整理。于是，当某一天你突然回想起曾经看到过什么内容时，用尽一切办法，也很难翻到当初的那个页面了。为了解决这一问题，WorldBrain&#39;s Memex 诞生了。它可以快速索引网页正文内容，而非标题和链接，还支持自然语言检索，读过哪些文章一清二楚。</p><figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_713147/15602229401920.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt data-original="https://cdn.sspai.com/editor/u_713147/15602229401920.png"></figure>￼<p>你可以在 <a href="https://chrome.google.com/webstore/detail/worldbrains-memex/abkfbakhjpmblaafnpgjppbmioombali" target="_blank" rel="noopener">Chrome 网上应用店</a> 和 <a href="https://addons.mozilla.org/en-US/firefox/addon/worldbrain/" target="_blank" rel="noopener">Firefox Add-ons</a> 免费获取 WorldBrain&#39;s Memex。</p><p><strong>关联阅读：</strong><a href="https://sspai.com/post/44088" target="_blank" rel="noopener">如何在 1000 条历史记录中搜到你已经忘记标题的网页？试试这个插件：Memex</a></p><h3 id="toc_22--NaN">达达划词翻译</h3><p>单词翻译扩展可能是竞争压力最大的领域之一，少数派此前也曾推出过一篇 <a href="https://sspai.com/post/44139" target="_blank" rel="noopener">专题介绍</a>。而尝试过诸多作品后，我的最终选择是达达划词翻译。它的 UI 设计简约美观，释义来自牛津词典，支持发音和词根词缀。此外，达达划词翻译还内置了生词本功能，基于艾宾浩斯记忆曲线进行温习提醒，帮助你科学掌握外文词汇。</p><figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_713147/15602229401932.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt data-original="https://cdn.sspai.com/editor/u_713147/15602229401932.gif"></figure>￼<figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_713147/15602229401944.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt data-original="https://cdn.sspai.com/editor/u_713147/15602229401944.png"></figure>￼<p>你可以在 <a href="https://chrome.google.com/webstore/detail/%E8%BE%BE%E8%BE%BE%E5%88%92%E8%AF%8D%E7%BF%BB%E8%AF%91/cajhcjfcodjoalmhjekljnfkgjlkeajl" target="_blank" rel="noopener">Chrome 网上应用店</a> 免费获取达达划词翻译。</p><h3 id="toc_23--NaN">书签侧边栏</h3><p>为了追求更大的有效显示面积，不少人会选择隐藏 Chrome 书签栏，但这也会带来一个新问题，那就是如何方便快捷的点击书签。而书签侧边栏则可以将 Chrome 的书签栏移动至浏览器两侧，并通过滑动或点击等方式唤出，还可以自定义其外观、位置、行为等，自由度较高。</p><figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_713147/15602229401956.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt data-original="https://cdn.sspai.com/editor/u_713147/15602229401956.png"></figure>￼<figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_713147/15602229401969.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt data-original="https://cdn.sspai.com/editor/u_713147/15602229401969.png"></figure>￼<p>你可以在 <a href="https://chrome.google.com/webstore/detail/bookmark-sidebar/jdbnofccmhefkmjbkkdkfiicjkgofkdh" target="_blank" rel="noopener">Chrome 网上应用店</a> 免费获取书签侧边栏。</p><h3 id="toc_24--NaN">Unpaywall</h3><p>尽管科学无国界，但部分知识却有壁垒。如果你需要参考一篇期刊论文，学校却没有购买相关授权，或许会看到下图所示的提示，只能另觅他处或自掏腰包了。其实，有相当一部分付费论文都可以从互联网免费获取，Unpaywall 就可以帮助我们找到它。启用后，Unpaywall 会在论文网页提示是否有免费版本，可以一键直达。</p><figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_713147/15602229401981.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt data-original="https://cdn.sspai.com/editor/u_713147/15602229401981.png"></figure>￼<p>你可以在 <a href="https://chrome.google.com/webstore/detail/unpaywall/iplffkdpngmdjhlpjmppncnlhomiipha" target="_blank" rel="noopener">Chrome 网上应用店</a> 和 <a href="https://addons.mozilla.org/en-US/firefox/addon/unpaywall/" target="_blank" rel="noopener">Firefox Add-ons</a> 免费获取 Unpaywall。</p><p>P.S. 与 Sci-Hub 不同，Unpaywall 由一家名为 Impactstroy 的非盈利机构出品，检索到的论文均来自正规合法渠道，如 Green Open Access 和作者个人网站等，请放心食用。</p><h2 id="toc_25--NaN">让代码更直观</h2><p>要想代码没 bug，除了祭祖女装 996 外，好看实用的浏览器扩展也能增分不少。在本节，我就为大家推荐 4 款程序员必备的 Chrome 扩展，希望能帮助你码途一路顺风。</p><h3 id="toc_26--NaN">GayHub</h3><p>作为全球最大的同性交友平台，GitHub 是不少程序员的工作必备网站，而 GayHub 就能让它更好用。它解决了 GitHub 浏览项目时的几个痛点，如在项目左侧显示文件目录树方便跳转、在右侧为 Markdown 说明文件添加 ToC 目录以供查看等。此外，你还可以用它全屏查看图片、快速复制代码，让 GitHub 更好用。</p><figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_713147/15602229401995.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt data-original="https://cdn.sspai.com/editor/u_713147/15602229401995.png"></figure>￼<p>你可以在 <a href="https://chrome.google.com/webstore/detail/gayhub/mdcffelghikdiafnfodjlgllenhlnejl" target="_blank" rel="noopener">Chrome 网上应用店</a> 免费获取 GayHub。</p><h3 id="toc_27--NaN">Refined GitHub</h3><p>Refined GitHub 为 GitHub 带来了数个 UI 及细节改进，如将 issues 通知设为未读、一键修复 merge 冲突、pull request 前二次确认、issue 原链接跳转、显示表态者头像等。如果你觉得原生 GitHub 还有哪些不便，不妨到 <a href="https://github.com/sindresorhus/refined-github" target="_blank" rel="noopener">Refined GitHub 主页</a> 提交新请求吧。</p><figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_713147/15602229402007.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt data-original="https://cdn.sspai.com/editor/u_713147/15602229402007.png"></figure>￼<p>你可以在 <a href="https://chrome.google.com/webstore/detail/refined-github/hlepfoohegkhhmjieoechaddaejaokhf" target="_blank" rel="noopener">Chrome 网上应用店</a> 和 <a href="https://addons.mozilla.org/en-US/firefox/addon/refined-github-/" target="_blank" rel="noopener">Firefox Add-ons</a> 免费获取 Refined GitHub。</p><h3 id="toc_28--NaN">OctoLinker</h3><p>在 GitHub 上在线查看代码时，纵使你可一目十行，也难免会被某个复杂的逻辑绕晕。这时，就到了请 OctoLinker 出场的时间。它可以识别包括 Java、Python、Node.js、Haskell 等在内的数十种语言在内的代码逻辑，将 <code>include</code>、<code>require</code>、<code>import</code> 等模块加载语句转换为可点击的链接，一键跳转至引用页。</p><figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_713147/15602229402018.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt data-original="https://cdn.sspai.com/editor/u_713147/15602229402018.jpg"></figure>￼<p>你可以在 <a href="https://chrome.google.com/webstore/detail/octolinker/jlmafbaeoofdegohdhinkhilhclaklkp" target="_blank" rel="noopener">Chrome 网上应用店</a> 和 <a href="https://addons.mozilla.org/en-US/firefox/addon/octolinker/" target="_blank" rel="noopener">Firefox Add-ons</a> 免费获取 OctoLinker。</p><h3 id="toc_29--NaN">JavaScript and CSS Code Beautifier</h3><p>顾名思义，JavaScript and CSS Code Beautifier 是一款可以美化网页 JS 、CSS 及 JSON 代码文件的 Chrome 扩展。只需打开任意一个源代码页，它就会提示你是否显示格式化后的代码，并支持多种主题切换及自定义样式效果，再也不用复制到 IDE 查看了。</p><figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_713147/15602229402030.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="美化前" data-original="https://cdn.sspai.com/editor/u_713147/15602229402030.png"><figcaption class="ss-image-caption">美化前</figcaption></figure>￼<figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_713147/15602229402043.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="美化后" data-original="https://cdn.sspai.com/editor/u_713147/15602229402043.png"><figcaption class="ss-image-caption">美化后</figcaption></figure>￼<figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_713147/15602229402056.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt data-original="https://cdn.sspai.com/editor/u_713147/15602229402056.png"></figure>￼<p>你可以在 <a href="https://chrome.google.com/webstore/detail/javascript-and-css-code-b/iiglodndmmefofehaibmaignglbpdald" target="_blank" rel="noopener">Chrome 网上应用店</a> 免费获取 JavaScript and CSS Code Beautifier。</p><h2 id="toc_30--NaN">让设计更简单</h2><p>如果你靠设计混饭吃，在日常工作中可能会遇到这些问题：想下载当前页面中的全部图片又懒得依次点击、看到一组不错的配色想保存又不知具体色值、觉得网页用的字体超赞却难觅具体名称……而本节介绍的 6 款扩展就能满足你的需求。</p><h3 id="toc_31--NaN">图片助手</h3><p>在 Dribbble、Pinterest、花瓣等网站看到一组设计素材时，你可能会想要将其保存至本地备用，而图片助手则可以帮助你将其一网打尽。它能够一键提取当前页面中的所有图片，允许你按尺寸、类型、URL 等筛选，还支持一次提取多个网页中的图片、加载当前页面中的链接以获取更多图片。</p><figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_713147/15602229402071.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt data-original="https://cdn.sspai.com/editor/u_713147/15602229402071.png"></figure>￼<p>你可以在 <a href="https://chrome.google.com/webstore/detail/imageassistant-batch-imag/dbjbempljhcmhlfpfacalomonjpalpko" target="_blank" rel="noopener">Chrome 网上应用店</a>、<a href="https://addons.mozilla.org/zh-CN/firefox/addon/ia-batch-image-downloader/" target="_blank" rel="noopener">Firefox Add-ons</a> 和 <a href="http://www.pullywood.com/ImageAssistant/" target="_blank" rel="noopener">官网</a> 免费获取图片助手。</p><p>P.S. 如果你曾搜索过 Chrome 图片批量下载扩展，可能会看到不少推荐 Fatkun 的文章。它此前很长一段时间也是我的首选，但在一次更新后出现了静默弹窗、劫持搜索引擎、后台访问推广网页等行为，建议大家移除。</p><h3 id="toc_32--NaN">Color by Fardos</h3><p>无论是平面设计还是幻灯片演示，一套优秀的色彩方案都可以起到锦上添花的作用，而 Color by Fardos 就可以承包从取色到配色的全部流程。安装扩展后，只需输入名称，你就能找到相关颜色及其互补色、三色调等方案。你还可以点击屏幕上的任意颜色，实时预览调色效果，并保存至调色盘备用。</p><figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_713147/15602229402085.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt data-original="https://cdn.sspai.com/editor/u_713147/15602229402085.gif"></figure>￼<p>你可以在 <a href="https://chrome.google.com/webstore/detail/color-by-fardos/iibpgpkhpfggipbacjfeijkloidhmiei" target="_blank" rel="noopener">Chrome 网上应用店</a> 免费获取 Color by Fardos。</p><h3 id="toc_33--NaN">Site Palette</h3><p>偶遇一个设计精美的网站，想将其配色方案应用至自己的作品，Site Palette 就能帮上忙。它可以智能分析任意网页的主色调和配色方案，生成调色板，并按照 Material Design 等设计语言给出近似的颜色方案，方便后续设计工作。</p><figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_713147/15602229402098.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt data-original="https://cdn.sspai.com/editor/u_713147/15602229402098.png"></figure>￼<p>你可以在 <a href="https://chrome.google.com/webstore/detail/site-palette/pekhihjiehdafocefoimckjpbkegknoh" target="_blank" rel="noopener">Chrome 网上应用店</a> 获取 Site Palette，其专业版支持通过终端调用 API，但需按请求次数付费。</p><h3 id="toc_34--NaN">Dribbble Color Generator</h3><p>Dribbble 是世界著名的设计师交流网站，可以从上面发掘出许多优秀作品。而 Dribbble Color Generator 则可以帮助你下载任意作品的调色板，并保存为 .aco 或 .sketchpalette 文件，让你从此不再为配色担忧。</p><figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_713147/15602229402110.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt data-original="https://cdn.sspai.com/editor/u_713147/15602229402110.png"></figure>￼<p>你可以在 <a href="https://chrome.google.com/webstore/detail/dribbble-color-generator/cineoljoghlkpmnpcjcmbbpedgjbmpac" target="_blank" rel="noopener">Chrome 网上应用店</a> 和 <a href="https://addons.mozilla.org/en-US/firefox/addon/dribbble-color-generator/" target="_blank" rel="noopener">Firefox Add-ons</a> 免费获取 Dribble Color Generator。</p><h3 id="toc_35--NaN">Eagle</h3><p>Eagle 是一款集实用与美观于一体的设计素材管理工具，少数派此前也曾多次介绍过。而其官方 Chrome 扩展则允许你一键批量导入当前网页中的图片，或者直接截图保存。其抓取能力十分强大，支持按尺寸、格式等筛选，并自动识别重复图片，是设计师的好帮手。</p><figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_713147/15602229402122.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt data-original="https://cdn.sspai.com/editor/u_713147/15602229402122.png"></figure>￼<p>你可以在 <a href="https://chrome.google.com/webstore/detail/eagle/lieogkinebikhdchceieedcigeafdkid" target="_blank" rel="noopener">Chrome 网上应用店</a>、<a href="https://addons.mozilla.org/zh-CN/firefox/addon/eagle-app/" target="_blank" rel="noopener">Firefox Add-ons</a> 和 <a href="https://cn.eagle.cool/extensions" target="_blank" rel="noopener">官网</a> 获取 Eagle 浏览器扩展，需要配合主应用才能使用，欢迎前往 <a href="https://sspai.com/item/19" target="_blank" rel="noopener">少数派正版软件商城</a> 选购。</p><p><strong>关联阅读：</strong><br><a href="https://sspai.com/post/53224" target="_blank" rel="noopener">Eagle 1.9 更新：新增字体管理、以图搜图等，发现素材管理的更多可能</a><br><a href="https://sspai.com/post/46131" target="_blank" rel="noopener">保持热情与创新，他开发出了这款图片管理工具中的「印象笔记」：专访 Eagle | 幕后</a></p><h3 id="toc_36--NaN">WhatFont</h3><p>在网页上看到了好看的字体，怎么才能应用到自己的作品中？此前，我一直是右键「审查元素」，再细细搜寻，效率低下。而 WhatFont 则允许我们通过一次点击查看对应文本采用的字体、字重、字号、颜色等，还能预览字体样式和跳转至字体来源出处，让海报设计更容易。</p><figure tabindex="0" class="ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_713147/15602229402134.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt data-original="https://cdn.sspai.com/editor/u_713147/15602229402134.png"></figure>￼<p>你可以在 <a href="https://chrome.google.com/webstore/detail/whatfont/jabopobgcpjmedljpbcaablpmlmfcogm" target="_blank" rel="noopener">Chrome 网上应用店</a> 免费获取 WhatFont。</p></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="experience" scheme="https://eliasliangyu.github.io/tags/experience/"/>
    
  </entry>
  
  <entry>
    <title>如何读懂代码</title>
    <link href="https://eliasliangyu.github.io/2019/06/16/%E5%A6%82%E4%BD%95%E8%AF%BB%E6%87%82%E4%BB%A3%E7%A0%81/"/>
    <id>https://eliasliangyu.github.io/2019/06/16/如何读懂代码/</id>
    <published>2019-06-16T10:44:26.000Z</published>
    <updated>2019-06-19T14:39:37.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><b><a href="https://www.jianshu.com/p/1850db5d2891" target="_blank" rel="noopener">——/转载自简书jianshu.com/——</a><b></b></b></p><p>我们在写程序时，有不少时间都是在看别人的代码。 例如看小组的代码，看小组整合的守则，若一开始没规划怎么看， 就会看得云山雾罩不知其所然。</p><p>不管是参考也好，从开源抓下来研究也好，为了了解箇中含意，在有限的时间下，不免会对庞大的源代码解读感到压力。</p><p>以下来介绍一下读代码的心法：</p><ul><li>读懂程序代码，使心法皆为我所用。</li><li>摸清架构，便可轻松掌握全貌。</li><li>优质工具在手，读懂程序非难事。</li><li>望文生义，进而推敲组件的作用。</li><li>找到程序入口，再由上而下抽丝剥茧。</li><li>阅读的乐趣，透过程序认识作者。</li></ul><h2>读懂程序，使心法皆为我所用</h2><p>程序是别人写的，只有原作者才真的了解程序的用途及涵义。许多程员心里都有一种不自觉的恐惧感，深怕被迫去碰触其他人所写的程序。但是，与其抗拒接收别人的程序，不如彻底了解相关的语言和惯例，当成是培养自我实力的基石。</p><p>对大多数的程序员来说，撰写程序或许是令人开心的一件事情，但我相信，有更多人视阅读他人所写成的程序为畏途。许多人宁可自己重新写过一遍程序，也不愿意接收别人的程序，进而修正错误，维护它们，甚至加强功能。</p><p>这其中的关键究竟在何处呢？若是一语道破，其实也很简单，程序是别人写的，只有原作者才真的了解程序的用途及涵义。许多程序员心里都有一种不自觉的恐惧感，深怕被迫去碰触其他人所写的程序。这是来自于人类内心深处对于陌生事物的原始恐惧。</p><p>读懂别人写的程序，让你收获满满。不过，基于许多现实的原因，程序员时常受迫要去接收别人的程序。例如，同事离职了，必须接手他遗留下来的工作，也有可能你是刚进部门的菜鸟，而同事经验值够了，升级了，风水轮流转，一代菜鸟换菜鸟。甚至，你的公司所承接的项目，必须接手或是整合客户前一个厂商所遗留下来的系统，你们手上只有那套系统的源代码（运气好时，还有数量不等的文件） 。</p><p>诸如此类的故事，其实时常在程序员身边或身上持续上演着。许多程序员都将接手他人的程序，当做一件悲惨的事情。每个人都不想接手别人所撰写的程序员，因为不想花时间去探索，宁可将生产力花在产生新的程序，而不是耗费在了解这些程序上。</p><p>很遗憾的是，上述的情况对程序员来说很难避免。我们总是必须碰触到其他人所写成的程序，甚至必须了解它，加以修改。对于这项需求，在现今开放源代码的风气如此盛行的今日，你可以透过开放源码学习到新的技术，学习到高手的架构设计，大幅提高学习的效率及效果。你甚至可以直接自开放源代码项目中抽取，提炼出自己所需的程序，站在巨人的肩膀上，直接由彼端获得所需的生产力。从这个观点来看，读懂别人所写的程序，就不再只是从负面观点的“被迫接收” ，而是极具正面价值的“汲取养份。 ”</p><p>先了解系统架构与行为模式，再细读倘若撰写程序是程序员的重要技艺之一，那么读懂别人的程序，接着加以修改，也势必是另一个重要的技艺。</p><p>如果你不能熟悉这项工作，不仅在遭逢你所不愿面对的局面时，无法解决眼前接手他人程序的难题，更重要的是，当你看着眼前现成的程序，却不知如何从中撷取自己所需，导致最后只能入宝山空手回，望之兴叹。</p><p>接触他人的程序，大致上可以分为三种程度：</p><ol><li>了解</li><li>修改，扩充</li><li>抽取，提炼。</li></ol><p>了解别人的程序是最基础的工作，倘若不能了解自己要处理的程序，就甭论修改或扩充，更不可能去芜存菁，从中萃取出自己所需，回收再利用别人所撰写的程序。虽说是“阅读” ，但程序并不像文章或小说一样，透过这种做法，便能够获得一定程度的了解。阅读文章或小说时，几乎都是循序地阅读，你只消翻开第一页，一行行阅读下去即可。但是，有许多程序员在试着阅读其他人的程序时，却往往有不知如何读起的困难。</p><p>或许找到系统的第一页（也就是程序执行的启始点）并不难，但是复杂度高的系统，有时十分庞大，有时千头万绪。</p><p>从程序的启始点开始读起，一来要循序读完所有的程序旷日费时，二来透过这种方式来了解系统，很难在脑中构建出系统的面貌，进而了解到系统真正的行为。所以，阅读程序员的重点，不在于读完每一行程序员，而是在于有效率地透过探索及阅读，从而了解系统的架构及行为模式。以便在你需要了解任何片段的细节实现时，能够很快在脑上对映到具体的程序员位置，直到那一刻，才是细读的时机。</p><h3>熟悉沟通语言与惯例用语</h3><p>不论如何，有些基本的准备，是阅读他人程序员时必须要有的。</p><p>首先，你最好得了解程序员使用的编程语言。想要读懂法文写成的小说，总不能连法文都不懂吧。有些情况则很特殊。我们虽然不懂该程序员撰写所用的语言，但是因为现代语言的高阶化，而且流行的编程语言多半都是血统相近，所以即使不那么熟悉，有时也可勉力为之。</p><p>除了认识所用语言之外，再来就是要先确认程序员所用的命名惯例（命名惯例） 。了解命名惯例很重要，不同的程序员或开发团队，差异可能很大。</p><p>这命名惯例涵盖的范围通常包括了变数的名称，函数的名称，类别（如果是面向对象的话）的名称，源代码档案，甚至是项目建构目录的名称。倘若使用了像设计模式之类的方法，这些名称更有一些具体的表述方式。</p><p>命名惯例有点像是程序员在编程语言之上，另行建构的一组沟通行话。程序员会透过共通约束，遵守的命名惯例，来表达一些较高阶的概念。例如，有名的匈牙利式命名法，便将变数名称以属性，型别，说明合并在一起描述。对程序员来说，这种方式能够提供更丰富的资讯，以了解该变数的作用及性质。</p><p>对程序员阅读来说，熟悉这个做法之所以重要，是因为当你了解整个系统所采用的惯例时，你便能试着以他们所共同操用的语汇来进行理解。倘若，不能了解其所用的惯例，那么这些额外提供的资讯，就无法为你所用。像以设计模式写成的程序员，同样处处充满着模式的名称，诸如：工厂，门面，代理等等。以这些名称指涉的类别，也直接透过名称，表达了它们自身的作用。对于懂得这命名惯例的读者来说，不需要深入探索，也能很快捕捉到这些类别的意义。</p><p>当你拿到一套必须阅读的程序员时，最好先取得命名惯例的说明文件。然而，并不是每套程序员都附有此类的说明文件。另一个方式，就是自己到程序员中，大略浏览一遍，有经验的程序员可以轻易发掘出该系统所用的命名惯例。</p><p>常见的命名方式不脱那几类，这时候经验就很重要，倘若你知道的惯例越多，就越能轻易识别他人所用的惯例。如果运气很糟，程序员所用的惯例是前所未见的，那么你也得花点时间归纳，凭自己的力量找出这程序员命名上的规则。</p><h3>掌握程序员撰写者的心态与习惯</h3><p>大多数的程序员，基本上都依循一致的命名惯例。不过运气更差的时候，一套系统中可能会充斥着多套命名惯例。这有可能是因为开发团队由多组人马所构成，每组人马都有不同的文化，而在项目开发管理又没有管控得宜所造成。最糟的情况，程序员完全没有明显的惯例可言，这时候阅读的难度就更高了。</p><p>想要阅读程序员，得先试着体会程序员作者的“心” 。想要这么做，就得多了解对方所使用的语言，以及惯常运用的语汇。在下一回中，我们将继续探讨阅读程序员的相关议题。</p><h2>摸清架构，便可轻松掌握全貌</h2><p>在本文中，我们的重点放在：要了解一个系统，最好是采取由上至下的方式。先试着捕捉系统架构性的观念，不要过早钻进细节，因为那通常对于你了解全貌，没有多大的帮助。阅读程序员不需要从第一行读起，我们的目的并不是在于读遍每一段程序员。</p><p>基于许多原因，程序员需要阅读其他人所写成的程序员。而对程序设计2.0时代的程序员来说，最正面的价值在于，能读懂别人程序的人，才有能力从中萃取自己所需的程序，借以提高生产力。</p><h3>阅读程序员的目的，在于了解全貌而非细节</h3><p>想要读懂别人程序员的根本基础，便是了解对方所用的编程语言及命名惯例。有了这个基础之后，才算是具备了基本的阅读能力。正如我之前提到的─ ─想要读懂法文写成的小说，总不能连法文都不懂吧。阅读程序员和阅读文学作品，都需要了解撰写所用的语言及作者习用的语汇。</p><p>但我们在阅读文学作品通常是采循序的方式，也就是从第一页开始，一行一行地读下去，依循作者为你铺陈的步调，逐渐进到他为你准备好的世界里。阅读程序员却大大不同。我们很少从第一行开始读起，因为除非它是很简单的单执行绪程序，否则很少这么做。因为要是这么做，就很难了解整个系统的全貌。是的，我们这边提到了一个重点，阅读程序员的目的在于了解系统的全貌，而不是在于只是为了地毯式的读遍每一段程序员。</p><p>就拿面向对象编程语言所写成的系统来说，整个系统被拆解，分析成为一个个独立的类别。阅读个别类别的程序员，或许可以明白每项类别物件个别的行为。但对于各类别物件之间如何交互影响，如何协同工作，又很容易陷入盲人摸象的困境。这是因为各类别的程序员，只描述个别物件的行为，而片段的阅读就只能造就片面的认识。</p><h3>由上而下理清架构后，便可轻易理解组成关系</h3><p>如果你想要跳脱困境，不想浪费大量时间阅读程序员，却始终只能捕捉到对系统片段认识，就必须转换到另一种观点来看待系统。从个别的类别行为着手，是由下至上（自下而上）的方法;在阅读程序员时，却应该先采由上至下（自上而下）的方式。对程序员的阅读来说，由上至下意谓着，你得先了解整个系统架构。</p><p>系统的架构是整个系统的骨干，支柱。它表现出系统最突出的特征。知道系统架构究竟属于那一种类型，通常大大有益于了解系统的个别组成之间的静态及动态关系。有些系统因为所用的技术或框架的关系，决定了最上层的架构。例如，采用的Java Servlet的/ JSP的技术的应用系统，最外层的架构便是以J2EE的（或起码的J2EE中的Web容器）为根本。</p><p>使用的Java Servlet的/ JSP的技术时，决定了某些组成之间的关系。例如， Web容器依据web.xml中的内容载入所有的Servlets ，听众，以及过滤器。每当语境发生事件（例如初始化）时，它便会通知监听类别。每当它收到来自客户端的请求时，便会依循设定的所有过滤器链，让每个过滤器都有机会检查并处理此一请求，最后再将请求导至用来处理该请求的Servlet的。</p><p>当我们明白某个系统采用这样的架构时，便可以很容易地知道各个组成之间的关系。即使我们还不知道究竟有多少Servlets ，但我们会知道，每当收到一个请求时，总是会有个相对应的服务器来处理它。当想要关注某个请求如何处理时，我应该去找出这个请求对应的服务器。</p><h3>了解架构，必须要加上层次感</h3><p>同样的，以爪哇写成的网页应用程序中，也许会应用诸如Struts的之类的的MVC框架，以及像Hibernate的这样的资料存取框架。它们都可以视为最主要的架构下的较次级架构。而各个应用系统，甚至有可能在Struts的及休眠之下，建立自有的更次级的架构。</p><p>也就是说，当我们谈到“架构”这样的观念时，必须要有层次感。而不论是那一层级的架构，都会定义出各自的角色，以及角色间的关系。对阅读者来说，相较于直接切入最细微的单一角色行为，不如了解某个特定的架构中，究竟存在多少角色，以及这些角色之间的互动模式，比较能够帮助我们了解整个系统的运作方式。</p><p>这是一个很重要的关键，当你试着进到最细节处之前，应该先试着找出参与的角色，及他们之间的关系。例如，对事件驱动式的架构而言，有3个很重要的角色。一个是事件处理的分派器（事件调度） ，一个是事件产生者（事件发生器） ，另一个则是事件处理器（事件处理程序） 。</p><p>事件产生器产生事件，并送至事件分派器，而事件分派器负责找出各事件相对应的事件处理器，并且转交该事件，并命令事件处理器加以处理。像的图形用户界面的Windows应用程序，便是采用事件驱动式的架构。</p><p>当你知道此类的应用程序皆为事件驱动式的架构时，你便可以进一步得知，在这样的架构下会有3种主要的角色。虽然也许还不清楚整个系统中，究竟会需要处理多少事件的类型，但对你而言，已经建立了对系统全貌最概观的认识。</p><p>虽然你还不清楚所有的细节，但诸如确切会有那些事件类型之类的资讯，在此刻还不重要─ ─不要忘了，我们采取的是由上而下的方式，要先摸清楚主建筑结构，至于壁纸的花色怎么处理，那是到了尾声时才会做的事。</p><h3>探索架构的第一件事：找出系统如何初始化</h3><p>有经验的程序员，对于时常被运用的架构都很熟悉。常常只需要瞧上几眼，就能明白一个系统所用的架构，自然就能够直接联想到其中会存在的角色，以及角色间的关系。然而，并不是每个系统所用的架构，都是大众所熟悉，或是一眼能够望穿的。这时候，你需要探索。目标同样要放在界定其中的角色，以及角色间的静态，动态关系。</p><p>不论某个系统所采用的架构是否为大部分人所熟知的，在试着探索一个系统的长相时，我们应该找出来几个答案，了解在它所用的架构下，下列这件事是如何被完成的：一，系统如何初始化，二，与这个系统相接的其他系统（或使用者）有那些，而相接的界面又是什么;三，系统如何反应各种事件，四，系统如何处理各种异常及错误。</p><p>系统如何初始化是很重要的一件事，因为初始化是为了接下来的所有事物而做的准备。从初始化的方式，内容，能知道系统做了什么准备，对于系统会有什么行为展现，也就能得窥一二了。之所以要了解与系统相接的其他系统（或使用者），为的是要界定出系统的边界。其他的系统可能会提供输入给我们所探索的系统，也可能接收来自这系统的输出，了解这边界所在，才能确定系统的外观。</p><p>而系统所反应的事件类型，以及如何反应，基本上就代表着系统本身的主要行为模式。最后，我们必须了解系统处理异常及错误的方式，这同样也是系统的重要行为，但容易被忽略。之前，我们提到必须先具备一个系统的语言基础，才能够进一步加以阅读，而在本文中，我们的重点放在：要了解一个系统，最好是采取由上至下的方式。先试着捕捉系统架构性的观念，不要过早钻进细节，因为那通常对于你了解全貌，没有多大的帮助。</p><h2>优质工具在手，读懂程序非难事</h2><p>系统的复杂度往往超过人脑的负荷。阅读程序员的时候，你会需要更多工具提供协助。使用好的整合式开发环境（ IDE ）的或文字编辑器，就能提供最基本的帮助。</p><p>阅读程序员的动作，可以是很原始的，利用最简单的文字编辑器，逐一开启源代码，然后凭借着一己的组织能力，在不同的程序员间跳跃，拼凑出脑中想要构建的图像。</p><p>不过，系统的复杂度往往超过人脑的负荷。阅读程序员的时候，你会需要更多工具提供协助。使用好的整合式开发环境（ IDE ）的或文字编辑器，就能提供最基本的帮助。</p><h3>善用文字编辑器或IDE中，加速解读程序员</h3><p>许多文字编辑器提供了常见编程语言的语法及关键字标示功能。这对于阅读来说，绝对能够起很大的作用。有些文字编辑器（例如我常用的编辑器及偶而使用的记事本+ + ），甚至能够自动列出某个原始档中所有定义的函数清单，更允许你直接从清单中选择函数，直接跳跃到该函数的定义位置。这对于阅读程序员的人来说，就提供了极佳的便利性。</p><p>因为在阅读程序员时，最常做的事，就是随着程序中的某个控制流，将阅读的重心，从某个函数移至它所调用的另一个函数。所以对程序员来说，阅读程序员时最常做的事之一就是：找出某个函数位在那一个原始档里，接着找到该函数所在的位置。</p><p>好的的IDE能够提供的协助就更多了。有些能够自动呈现一些额外的资讯，最有用的莫过于函数的原型宣告了。例如，有些的IDE支援当游标停留在某函数名称上一段时间后，它会以提示的方式显示该函数的原型宣告。</p><p>对阅读程序员的人来说，在看到程序员中调用到某个函数时，可以直接利用这样的支援，立即取得和这个函数有关的原型资讯，马上就能知道调用该函数所传入的各个引数的意义，而不必等到将该函数的定义位置找出后，才能明白这件事。</p><h4><code>grep</code>是一个基本而极为有用的工具</h4><p>除了选用好的文字编辑器或的IDE 之外，还有一个基本，但却极为有用的工具，它就是<code>grep</code>。熟悉的Unix/Linux系统的程序员对<code>grep</code>这个程序多半都不陌生。 <code>grep</code> 最大的用途，在于它允许我们搜寻某个目录（包括递回进入所有子目录）中所有指定档案，是否有符合指定条件（常数字串或正规表示式）档案。</p><p>倘若有的话，则能帮你指出所在的位置。这在阅读程序员时的作用极大。当我们随着阅读的脚步，遇上了任何一个不认识，但自认为重要的类别，函数，资料结构定义或变数，我们就得找出它究竟位在这茫茫程序员海中的何处，才能将这个图块从未知变为已知。</p><p>grep之所以好用，就是在于当我们发现某个未知的事物时，可以轻易地利用它找出这个未知的事物究竟位在何方。此外，虽说grep按是Unix系统的标准公用程序之一，但是像视窗这样子的平台，也有各种类型的<code>grep</code>命令。对于在视窗环境工作的程序员来说，可以自行选用觉得称手的工具。</p><h4><code>gtags</code> 可建立索引，让搜索更有效率</h4><p><code>grep</code> 虽然好用，但是仍然有一些不足之处。第一个缺点在于它并不会为所搜寻的源代码档案索引。每当你搜寻时，它都会逐一地找出所有的档案，并且读取其中的所有内容，过滤出满足指定条件的档案。当项目的源代码数量太大时，就会产生搜寻效率不高的问题。</p><p>第二个缺点是它只是一个单纯的文字档搜寻工具，本身并不会剖析源代码所对应的语言语法。当我们只想针对“函数”名称进行搜寻时，它有可能将注解中含有该名称的源代码，也一并找了出来。</p><p>针对<code>grep</code>的缺点，打算阅读他人程序员的程序员，可以考虑使用像是<code>gtags</code>这样子的工具。 <code>gtags</code>是源代码的GNU全局标记系统，它不只搜寻文字层次，而且因为具备了各种语言的语法剖析器，所以在搜寻时，可以只针对和语言有关的元素，例如类别名称，函数名称等。</p><p>而且，它能针对源代码的内容进行索引，这意谓一旦建好索引之后，每次搜寻的动作，都毋需重新读取所有源代码的内容并逐一搜寻。只需要以现成的索引结构为基础，即可有效率的寻找关键段落。</p><p><code>gtags</code> 提供了基于命令列的程序，让你指定源代码所在的目录执行建立索引的动作。它同时也提供程序让你得如同操作grep按一般，针对索引结构进行搜寻及检索。它提供了许多有用的检索方式，例如找出项目中定义某个资料结构的档案及定义所在的行号，或者是找出项目中所有引用某资料结构的档案，以及引用处的行号。</p><p>这么一来，你就可以轻易地针对阅读程序员时的需求予以检索。相较于<code>grep</code> 按所能提供的支援，<code>gtags</code>这样的工具，简直是强大许多。</p><h2>望文生义，进而推敲组件的作用</h2><p>先建立系统的架构性认识，然后透过名称及命名惯例，就可以推测出各组件的作用。例如：当AOL的Winamp尝试着初始化一个插件时，它会调用这个结构中的初始化函数，以便让每个插件程序有机会初始化自己。当AOL的Winamp打算结束自己或结束某个插件的执行时，便会调用结束函数。</p><p>在阅读程序的细节之前，我们应先试着捕捉系统的运作情境。在采取由上至下的方式时，系统性的架构是最顶端的层次，而系统的运作情境，则是在它之下的另一个层次。</p><h2>好的说明文件难求，拼凑故事的能力很重要</h2><p>有些系统提供良善的说明文件，也许还利用UML的充分描述系统的运行情况。那么对于阅读者来说，从系统的分析及设计文件着手，便是快速了解系统运作情境的一个途径。</p><p>但是，并不是每个软件项目都伴随着良好的系统文件，而许多极具价值的开放源代码项目，也时常不具备此类的文件。对此，阅读者必须尝试自行捕捉，并适度地记录捕捉到的运作情境。</p><p>我喜欢将系统的运作情境，比拟成系统会上演的故事情节。在阅读细节性质的程序员前，先知道系统究竟会发生那些故事，是必备的基本功课。你可以利用熟悉或者自己发明的表示工具，描述你所找到的情境。甚至可以只利用简单的列表，直接将它们列出。只要能够达到记录的目的，对程序员阅读来说，都能够提供帮助。或者，你也可以利用基于UML中的类别图，合作图，循序图之类的表示方法，做出更详细的描述。<br>当你能够列出系统可能会有的情境，表示你对系统所具备的功能，以及在各种情况下的反应，都具备概括性的认识。以此为基础，便可在任何需要的时候，钻进细节处深入了解。</p><h2>探索架构的第一步──找到程序的入口</h2><p>在之前，我们在一个开发项目中，曾经需要将系统所得到的的MP3音讯档，放至iPod的这个极受欢迎的播放设备中。</p><p>虽然iPod的本身也可以做为可移动式的储存设备，但并不是单纯地将MP3播放档案放到中的iPod ，就可以让苹果的播放器认得这个档案，甚至能够加以播放。<br>这是因为苹果利用一个特殊的档案结构（ iTunes的数据库） ，记录播放器中可供播放的乐曲，播放清单以及乐曲资讯（例如专辑名称，乐曲长度，演唱者等） 。为了了解并且试着重复使用既有的程序员，我们找到了一个AOL的Winamp的iPod的外挂程序（插件） 。</p><p>AOL的Winamp是个人电脑上极受欢迎的播放软件，而我们找到的外挂程序，能让的软件直接显示连接至电脑的的iPod中的歌曲资讯，并且允许的软件直接播放。</p><p>我们追踪与阅读这个外挂程序的思路及步骤如下，首先，我们要先了解外挂程序的系统架构。很明显的，大概浏览过源代码后，我们注意到它依循着AOL的Winamp为插件程序所制定的规范，也就是说，它是实现成的Windows上的DLL的，并且透过一个叫做winampGetMediaLibraryPlugin的DLL的函数，提供一个名为winampMediaLibraryPlugin的结构。<br>当我们不清楚系统的架构究竟为何时，我们会试着探索，而第一步，便是找到程序的入口。如何找到呢？这会依程序的性质不同而有所差别。<br>对一个本身就是可独立执行的程序来说，我们会找启动程序的主要函数，例如对的C/C++来说就是<code>main()</code>函数，而对Java来说，便是静态方法<code>main()</code> 。在找到入口后，再逐一追踪，摸索出系统的架构。</p><p>但有时，我们阅读的程序如果是类库或函数库，本身并不具单一入口，此类的程序具有多重的入口──每个允许用户端程序调用的函数或类别，都是它可能的入口。</p><p>例如，对AOL的Winamp的 iPod的插件来说，它是一个动态链接库形式的函数库，所以当我们想了解它的架构时，必须要先找出它对外提供的函数，而对的Windows的DLL来说，对外提供的函数，皆会以dllexport这个关键字来修饰。所以，不论是利用grep按或gtags之类的工具，我们可以很快从源代码中，找到它只有一个DLL的函数（这对我们而言，真是一个好消息） ，而这个函数便是上述的winampGetMediaLibraryPlugin 。</p><h2>系统多会采用相同的架构处理插件程序</h2><p>如果经验不够的话，也许无法直接猜出这个函数的作用。 不过，如果你是个有经验的程序员，多半能从函数所回传的结构，猜出这个函数实际的用途。而事实上，当你已经知道它是一个插件程序时，就应该要明白，它可能采用的，就是许多系统都采用的相同架构处理插件程序。</p><p>当一个系统采用所谓插件形式的架构时，它通常不会知道它的插件究竟会怎么实现，实现什么功能。它只会规范插件程序需要满足某个特定界面。当系统初始化时，所有的插件都可以依循相同的方式，向系统注册，合法宣示自己的存在。</p><p>虽然系统并不确切知道插件会有什么行为展现，但是因为它制定了一个标准的界面，所以系统仍然可以预期每个插件能够处理的动作类型。这些动作具体上怎么执行，对系统来说并不重要。这也正是面向对象程序设计中的“多态”观念。</p><h2>随着实践经验，归纳常见的架构模式</h2><p>我想表达的重点，是当你“涉世越深”之后，所接触的架构越多，就越能触类旁通。只需要瞧上几眼，就能明白系统所用的架构，自然就能够直接联想到其中可能存在的角色，以及角色间的关系。</p><p>像上述的插件程序手法，时常可以在许多允许“外挂”程序员的系统中看到。所以，有经验的阅读者，多半能够立即反应，知道像这样的系统的软件，应该是让每个插件程序，都写成DLL的函数库。</p><p>而每个插件的DLL的函数库中，都必须提供<code>winampGetMediaLibraryPlugin()</code>这个函数 。如果你熟悉设计模式，你更会知道这是简单工厂方法这个设计模式的运用。<br><code>winampGetMediaLibraryPlugin()</code> 所回传的<code>winampMediaLibraryPlugin</code>结构，正好就描述了每个AOL的Winamp插件的实现内容。</p><h3>善用名称可加速了解</h3><p>利用<code>gtags</code>这个工具，我们立即发现，这个插件它所定义的初始化，退出， <code>PluginMessageProc</code>这三个名称，都是函数名称。这暗示在方法重载的作用下，它们都是在某些时间点，会由AOL的Winamp核心本体调用的函数。</p><p>名称及命名惯例是很重要的。看到 “初始化” ，我们会知道它的作用多半是进行初始化的动作，而“退出”大概就是结束时处理函数，而PluginMessageProc多半就是各种讯息的处理常式（过程通常是程序的简写，所以<code>PluginMessagePro</code>c意指插件讯息程序）了。</p><p>“望文生义”很重要，我们看到函数的名称，就可以猜想到它所代表的作用，例如：当AOL的Winamp尝试着初始化一个插件时，它会调用这个结构中的初始化函数，以便让每个插件程序有机会初始化自己;当AOL的Winamp打算结束自己或结束某个插件的执行时，便会调用退出函数。当AOL的Winamp要和插件程序沟通时，它会发送各种不同的讯息至插件，而插件程序必须对此做出回应。</p><p>我们甚至不需要检查这几个函数的内容，就可以做出推测，而这样的假设，事实上也是正确的。</p><h2>阅读的乐趣：透过程序员认识作者</h2><p>即便每个人的写作模式多半受到他人的影响，程序通常还是会融合多种风格，而成为自己独有的特色，如果你知道作者程序设计的偏好，阅读他的程序就更得心应手。</p><p>阅读程序时，多半会采取由上而下，抽丝剥茧的方式。透过记录层层展开的树状结构，程序员可以逐步地建立起对系统的架构观，而且可以依照需要的粒度（粒度） ，决定展开的层次及精致程度。</p><p>建立架构观点的认识是最重要的事情。虽然这一系列的文章前提为“阅读他人的程序” ，但我们真正想做的工作，并不在于彻底地详读每一行程序员的细节，而是想要透过重点式的程序“摘读” ，达到对系统所需程度的了解。每个人在阅读程序员的动机不尽相同，需要了解的程度也就有深浅的分别。只有极为少数的情况下，你才会需要细读每一行程序。</p><h3>阅读程序是新时代程序员必备的重要技能</h3><p>本文至此已近尾声，回顾曾探讨的主题，我们首先研究了阅读程序的动机。尤其在开放源代码的风气如此之盛的情况下，妥善利用开放源代码所提供的资源，不仅能够更快学习到新的技术，同时在源代码版权合适时，还可以直接利用现成的程序，大幅地提高开发阶段的生产力。所以，阅读程序俨然成为了新时代程序员必备的重要技能之一。</p><p>接着，我们提到了阅读程序前的必要准备，包括了对编程语言，命名惯例的了解等等。在此之后，我们反覆提起了“由上而下”的阅读方向的重要性。<br>由上而下的阅读方式，是因为我们重视架构更胜于细节。从最外层的架构逐一向内探索，每往内探索一层，我们了解系统的粒度就增加了一个等级。当你识别出系统所用的架构时，便能够轻易了解在这个架构下会有的角色，以及它们之间的动态及静态的关系。如此一来，许多资讯便不言可喻，毋需额外花费力气，便能够快速理解。</p><h3>好的名称能够摘要性地指出实例的作用</h3><p>追踪源代码时，固然可以用本来的方式，利用编辑器开启所需的档案，然后利用编辑器提供的机制阅读，但是倘若能够善用工具，阅读程序员的效率及品质都能大大提升。在本文中，我们介绍了一些工具，或许你还可以在坊间找到其他更有用的工具。</p><p>我在这一系列的文章中，实际带着大家阅读，追踪了一个名为ml_pod的开放源代码项目。它是一个AOL的Winamp的iPod的外挂程序。在追踪的过程中，我们试着印证这一系列文中所提到的观念及方法。我们采用逐渐开展的树状结构来记录追踪的过程，并借以建立起对系统的概观认识。</p><p>就源代码的阅读来说，之前的讨论涉及了工具面及技巧面。但还有一些主题不在这两个范畴之内，例如，善用名称赋予你的提示。名称做为隐喻（隐喻）的作用很大，好的名称能够摘要性地点出实体的作用，例如我们看到<code>autoDetectIpod()</code>，自然而然能够想像它的作用在于自动（自动）侦测（检测）的iPod的存在。</p><p>我们在展开树状结构时，有时候需要预看一层，有时却不需要这么做，便可得到印证。程序员都会有惯用的名称以及组合名称的方法，倘若能够从名称上理解，便毋需钻进细节，可以省去相当多的时间。例如，当我们看到parseIpodDb （ ）时，便可以轻易了解它是剖析（解析）的iPod的资料库（ DB ）的，因此便不需要立即钻进parseIpodDb （ ）中查看底细。</p><p>尽管如此，能否理解程序命名的用意，和自身的经验以及是否了解原作者的文化背景，是息息相关的。</p><p>命名本身就是一种文化产物。不同的程序员文化，就会衍生出不同的命名文化。当你自己的经验丰富，看过及接触过的程序员也多时，对于名称的感受及联想的能力自然会有不同。</p><p>这种感受和联想的能力，究竟应该如何精进，很难具体描述。就我个人的经验，多观察不同命名体系的差异，并且尝试归纳彼此之间的异同，有助于更快地提升对名称的感受及联想力。</p><h3>转换立场，理解作者的思考方式</h3><p>除了工具及技巧之外， “想要阅读程序，得先试着阅读写这个程序的程序员的心。 ”这句话说来十分抽象，或许也令人难以理解。</p><p>当你在阅读一段程序员时，或许可以试着转换自己的立场，从旁观者的角度转换成为写作者的心态，揣摩原作者的心理及处境。当你试着设身处地站在他的立场，透过他的思考方式来阅读，追踪他所写下的程序员，将会感觉更加流畅。</p><p>许多软件项目，都不是由一个程序员所独力完成。因此，在这样的项目中，便有可能呈现多种不同的风格。</p><p>许多项目会由架构师决定主体的架构及运作，有既定实施的命名惯例，及程序设计需要遵守方针。在多人开发的模式下，越是好的软件项目，越看不出某程序片段究竟是由谁所写下的。</p><p>不过，有些开放源代码的项目，往往又整合了其他开放源代码的项目。有的时候，也很难求风格的统一，便会出现混杂的情况。好比之前提到的ml_pod项目，因为程序中混合了不同的来源，而呈现风格不一致的情况。</p><p>我在阅读非自己所写的程序时，会观察原作者写作的习惯，借以对应到脑中所记忆的多种写作模型。在阅读的过程中，读完几行程序，我会试着猜想原作者在写下这段程序时的心境。他写下这段程序的用意是什么？为什么他会采取这样的写法？顺着原作者的思考理路阅读，自己的思考才能更贴近对方写作当时的想法。</p><p>当你短暂化身为原作者时，才能更轻易的理解他所写下的程序。 如果你能知道原作者的背景，程序设计时的偏好，阅读他的程序，就更能得心应手了。</p><h3>从程序员着手认识作者独有的风格，进而见贤思齐</h3><p>我在阅读别人写下的程序时，我会试着猜想，原作者究竟是属于那一种“流派”呢？每个人都有自己独特的写作模式，即便每个人的写作模式多半受到他人的影响─ ─不论是书籍的作者，学习过程中的指导者，或一同参与项目的同侪，但每个程序员通常会融合多种风格，而成为自己独有的风格。</p><p>面向对象的基本教义派，总是会以他心中觉得最优雅的面向对象方式来撰写程序。而阅读惯用，善用设计模式的程序员所写下的程序时，不难推想出他会在各种常见的应用情境下，套用哪些模式。</p><p>有些时候，在阅读之初，你并不知道原作者的习性跟喜好，甚至你也不知道他的功力。但是，在阅读之后，你会慢慢地从一个程序员所写下的程序，开始认识他。</p><p>你或许会在阅读他人的程序时，发现令人拍案叫绝的技巧或设计。你也有可能在阅读的同时，发现原作者所留下的缺失或写作时的缺点，而暗自警惕于心。这也算是阅读他人程序时的一项乐趣。</p><p>当你从视阅读他人的程序为畏途，转变成为可以从中获取乐趣的时候，我想，你又进到了另一个境界。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="experience" scheme="https://eliasliangyu.github.io/tags/experience/"/>
    
  </entry>
  
  <entry>
    <title>给博客添加评论功能</title>
    <link href="https://eliasliangyu.github.io/2019/06/16/%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/"/>
    <id>https://eliasliangyu.github.io/2019/06/16/给博客添加评论功能/</id>
    <published>2019-06-15T16:42:35.000Z</published>
    <updated>2019-06-15T17:23:21.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 class="title clock">给博客添加评论功能</h1><p>Hexo的评论系统有很多，常见的有以下几个：</p><ul><li>多说：（凉了）</li><li>网易云跟帖：（也凉了）</li><li>畅言：<a href=" http://changyan.kuaizhan.com" target="_blank" rel="noopener"> http://changyan.kuaizhan.com</a> （需要备案，属实麻烦）</li><li>来必力LiveRe：<a href="https://livere.com " target="_blank" rel="noopener">https://livere.com </a>（韩国网站，使用邮箱注册）</li><li>Hypercomments：<a href="https://www.hypercomments.com " target="_blank" rel="noopener">https://www.hypercomments.com </a>（俄罗斯的，战斗名族）</li><li>valine : <a href="https://github.com/xCss/Valine" target="_blank" rel="noopener">https://github.com/xCss/Valine</a>（大家都用我不用说不过去）</li></ul><p>Hypercomments和LiveRe都是国外的，加载速度贼慢，甚至有被墙的可能。我刚最初使用的来必立LiveRe由于是韩国服务器不仅加载速度极慢，且评论需要认证个人社交账号，认证也比较缓慢，对于博客这类及时观看类的网站来说极其不合适，但也不是没有优点，评论框设计的倒是很美观，在翻看别人的博客搭建经验后找到了一个好用简单的评论系统，那就是 valine。</p><h2 id="ss-H2-1557303512937">开启Valine</h2><p>我使用的是archer主题，本身就已经集成了valine，因此正常情况下是按照官方文档走就可以了，几分钟就可以上线评论系统。</p><p><img src="//eliasliangyu.github.io/2019/06/16/给博客添加评论功能/Valine.png" alt="Valine-gitub"></p><p></p><h2 id="ss-H2-1557303512937">注册Leancloud</h2><p>评论系统都是放在Leancloud的服务器上的，个人部署的网页仅仅是展示，因此需要在官网注册一个账号。<a href="https://leancloud.cn" target="_blank" rel="noopener">Leancloud官网</a></p><p>注册完成提示需要创建一个应用，之后进入<b>应用->设置->应用key</b></p><p>获取你的App ID和App Key，如图：</p><p><img src="//eliasliangyu.github.io/2019/06/16/给博客添加评论功能/Key.jpg" alt="ID &amp; Key"></p><p></p><h2 id="ss-H2-1557303512937">更改配置文件</h2><p>打开主题配置文件_config.yml，找到valine，填入App ID和App Key。</p><pre class="prettyprint"><code class=" hljs vbnet">valine:  enable: <span class="hljs-literal">true</span>  appid:  your app id  appkey: your app <span class="hljs-keyword">key</span></code></pre><p>之后在<b>安全中心->Web安全域名</b>, 把你的项目域名加入；</p><h2 id="ss-H2-1557303512937">完成</h2><p>最后在Hexo根目录生成上传文件进行更新上传，完成后刷新页面即可看到评论框了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Course" scheme="https://eliasliangyu.github.io/tags/Course/"/>
    
  </entry>
  
  <entry>
    <title>纪念iPhone XR刷机成砖</title>
    <link href="https://eliasliangyu.github.io/2019/06/14/%E7%BA%AA%E5%BF%B5iPhone-XR%E5%88%B7%E6%9C%BA%E6%88%90%E7%A0%96/"/>
    <id>https://eliasliangyu.github.io/2019/06/14/纪念iPhone-XR刷机成砖/</id>
    <published>2019-06-14T08:36:01.000Z</published>
    <updated>2019-06-16T07:23:11.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 class="title clock">纪念iPhone XR刷机成砖</h1><p>本人于之前将iPhone XR刷成ios13尝鲜，刚上手体验并未发现明显BUG，只是系统的中英文显示有些混乱，例如提醒事项并未汉化。</p><p>未曾想，这几日频繁出现个别应用无法打开，闪退，十分影响体验，遂决定降级至12.4。</p><p>本人自诩刷机经验丰富，并未进行备份，然未曾想刷机失败......只得恢复出厂模式，十分蛋疼......</p><p>吃一堑长一智，今后折腾之前必先备份保平安，以此博文为记。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Apple ios" scheme="https://eliasliangyu.github.io/tags/Apple-ios/"/>
    
  </entry>
  
  <entry>
    <title>如何搭建属于自己的个人博客</title>
    <link href="https://eliasliangyu.github.io/2019/06/12/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://eliasliangyu.github.io/2019/06/12/如何搭建属于自己的个人博客/</id>
    <published>2019-06-12T04:36:01.000Z</published>
    <updated>2019-06-19T14:40:09.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><b><a href="https://sspai.com/post/54608" target="_blank" rel="noopener">——/转载自少数派sspai.com/——</a><b></b></b></p><p>互联网从诞生发展至今日，每天有无数的人在上面留下自己的足迹，他们用它记录生活、抒发情感、分享见解，这一切都离不开一个可以承载文字的平台，一个独立的、由自己掌控的平台，而 GitHub Pages 就是这么一个平台。</p><p>在这个平台里你可以使用自己的个性域名；可以在海量的主题里挑选最适合你的那一款，如果你技术极客，也可以根据自己的喜好，设计属于自己的个性化页面；你既可以在线创建和发布网站，也可以在本地通过客户端工具或者命令行进行网站和内容的管理。</p><p>你完全可以通过 GitHub Pages 展示和输出自身价值，甚至可以把它打造成属于自己的互联网「身份证」。</p><h2 id="ss-H2-1557303512937">为什么使用 GitHub Pages</h2><p>如果你把他作为一个轻量级的个人博客服务，GitHub Pages 相较 WordPress 之类的建站服务有什么优势呢？</p><ul><li>首先他是完全免费的，相较其他的同类产品，他能替你省下一笔服务费，节约下的钱可以让你买一些其他的会员服务；</li><li>无须自己购买云服务进行搭建，只需按步骤一步步操作即可，即使你不懂他的技术细节；</li><li>支持的功能多，玩法丰富，你可以绑定你的域名、使用免费的 HTTPS、自己 DIY 网站的主题、使用他人开发好的插件等等；</li><li>当完成搭建后，你只需要专注于文章创作就可以了，其他诸如环境搭建、系统维护、文件存储的事情一概不用操心，都由 GitHub 处理</li></ul><p>当然了，作为一款免费的服务，我们也是要遵守 GitHub 官方使用建议和限制，在使用的时候项目和网站的大小不要超过 1GB，也不要过于频繁的更新网站的内容（每小时不超过 10 个版本），每个月的也要注意带宽使用上限为 100GB。</p><p>综合来看，GitHub Pages 依旧可以说是中小型博客或项目主页的最佳选项之一。</p><h2 id="ss-H2-1557303515619">如何使用 GitHub pages</h2><p>介绍了这么多，下面就具体来谈谈如何使用它。</p><h3 id="ss-H3-1557303562873">基本页面的生成</h3><p>首先你需要注册一个 GitHub 账号，并在个人主界面里选择创建一个新的 Repository 。</p><figure tabindex="0" draggable="false" class="ss-img-wrapper custom-width" contenteditable="false"><img src="https://cdn.sspai.com/20190506142539.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt width="620" data-original="https://cdn.sspai.com/20190506142539.jpg"><figcaption class="ss-image-caption"></figcaption></figure><p>进入页面后，在 Repository name 的位置填写域名，格式是 <code>username.GitHub.io</code>。</p><p><img src="https://www.markeditor.com/file/get/08738ebb06454701a76bda6bdaa1b8c3.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="图片" data-original="https://www.markeditor.com/file/get/08738ebb06454701a76bda6bdaa1b8c3.jpg"></p><p>创建成功之后，点击右上角的 Settings</p><figure tabindex="0" draggable="false" class="ss-img-wrapper custom-width" contenteditable="false"><img src="https://cdn.sspai.com/20190506142601.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt width="620" data-original="https://cdn.sspai.com/20190506142601.jpg"><figcaption class="ss-image-caption"></figcaption></figure><p>找到 GitHub Pages 选项，选择一个 GitHub 官方提供的主题</p><figure tabindex="0" draggable="false" class="ss-img-wrapper custom-width" contenteditable="false"><img src="https://cdn.sspai.com/20190506142607.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt width="620" data-original="https://cdn.sspai.com/20190506142607.jpg"><figcaption class="ss-image-caption"></figcaption></figure><p>这里我们就随意选择一个主题 Cayman，来看看他的效果是什么样的</p><figure tabindex="0" draggable="false" class="ss-img-wrapper custom-width" contenteditable="false"><img src="https://cdn.sspai.com/20190506143205.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt width="620" data-original="https://cdn.sspai.com/20190506143205.png"><figcaption class="ss-image-caption"></figcaption></figure><p>选择完毕之后 GitHub Pages 就会自动帮你生成好网站，在他跳转的界面点击 Commit changes 按钮，网站就可以访问了。</p><figure tabindex="0" draggable="false" class="ss-img-wrapper custom-width" contenteditable="false"><img src="https://cdn.sspai.com/20190506143333.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt width="620" data-original="https://cdn.sspai.com/20190506143333.gif"><figcaption class="ss-image-caption"></figcaption></figure><p>在浏览器里输入你的项目名称，比如 <a href="https://brick713.GitHub.io/" target="_blank" rel="noopener">brick713.GitHub.io</a>，就可以看到，你刚刚选择的主题的个人网站的页面了。</p><figure tabindex="0" draggable="false" class="ss-img-wrapper custom-width" contenteditable="false"><img src="https://cdn.sspai.com/20190506143441.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt width="620" data-original="https://cdn.sspai.com/20190506143441.png"><figcaption class="ss-image-caption"></figcaption></figure><p>到这里如果你只是想做一个例如可以随时在互联网上访问的简历，那么你只需要  GitHub Pages 项目的主页修改你 <a href="http://index.md" target="_blank" rel="noopener">index.md</a> 文件就可以了，比如我给出的这个模板。</p><figure tabindex="0" draggable="false" class="ss-img-wrapper custom-width" contenteditable="false"><img src="https://cdn.sspai.com/20190506143459.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt width="620" data-original="https://cdn.sspai.com/20190506143459.png"><figcaption class="ss-image-caption"></figcaption></figure><p>修改完后，点击上图中左下角的 Commit Changes，然后访问你的自定义域名你就可以看到如下的样式了。</p><figure tabindex="0" draggable="false" class="ss-img-wrapper custom-width" contenteditable="false"><img src="https://cdn.sspai.com/20190506143603.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt width="620" data-original="https://cdn.sspai.com/20190506143603.png"><figcaption class="ss-image-caption"></figcaption></figure><p>如果你想做一个功能更丰富的博客，那我们继续往下走。</p><h3 id="ss-H3-1557303571087">配置自定义域名并免费使用 HTTPS</h3><p>在 2018 年 5 月 1 日之后，GitHub Pages 已经开始提供免费为自定义域名开启 HTTPS 的功能，并且大大简化了操作的流程，现在用户已经不再需要自己提供证书，只需要将自己的域名使用 CNAME 的方式指向自己的 GitHub Pages 域名即可。</p><p>首先在你的 DNS 解析里添加一条解析记录，例如我选择添加子域名 <code>blog.moyu.life</code> 通过 CNAME 的方式指向我刚刚自定义的 GitHub Pages 域名 <code>brick713.GitHub.io</code>。添加完成后等待 DNS 解析的生效（DNS 的解析记录生效到全球可能需要几分钟时间）。</p><figure tabindex="0" draggable="false" class="ss-img-wrapper custom-width" contenteditable="false"><img src="https://cdn.sspai.com/20190508161054.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt width="620" data-original="https://cdn.sspai.com/20190508161054.png"><figcaption class="ss-image-caption"></figcaption></figure><p>之后重新回到最开始进入过的 Settings 界面，找到 GitHub Pages 的设置，填写我们刚刚建立的子域名，以我自己的 blog.moyu.life 举例，点击保存。</p><figure tabindex="0" draggable="false" class="ss-img-wrapper custom-width" contenteditable="false"><img src="https://cdn.sspai.com/20190508161109.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt width="620" data-original="https://cdn.sspai.com/20190508161109.png"><figcaption class="ss-image-caption"></figcaption></figure><p>保存后 GitHub 需要一定的时间生成证书并确认域名的解析是否正常，我们只需要耐心的等待即可，成功后显示结果如下</p><figure tabindex="0" draggable="false" class="ss-img-wrapper custom-width" contenteditable="false"><img src="https://cdn.sspai.com/20190508161122.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt width="620" data-original="https://cdn.sspai.com/20190508161122.png"><figcaption class="ss-image-caption"></figcaption></figure><p>现在我们再访问 blog.moyu.life 就会发现，我们的自定义域名和 HTTPS 都生效了！可以看到证书是由著名的机构 Let&#39;s Encrypt 提供的。</p><figure tabindex="0" draggable="false" class="ss-img-wrapper custom-width" contenteditable="false"><img src="https://cdn.sspai.com/20190508161133.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt width="620" data-original="https://cdn.sspai.com/20190508161133.png"><figcaption class="ss-image-caption"></figcaption></figure><h3 id="ss-H3-1557303530640">网站的同步</h3><p>现在我们已经有了一个基本功能健全的网站了，接下来我们需要试着对博客的内容进行管理，并且给博客添加一些更个性化的设置，官方提供两种方式：</p><ul><li>命令行方式（Mac 和 Windows 确保拥有 Git 环境）</li><li>桌面客户端形式（需要安装官方提供的客户端）</li></ul><p>如果你没有任何 Git 的基础，也不想进行一些繁琐的配置，那么我推荐你使用桌面客户端的形式进行管理，如果你有一定的技术基础，那么 Git 的方式则更适合你。这里我两种方法都介绍一下。</p><p>首先在命令行中切换到你自定义的路径下，然后 Clone 下来你的项目（操作需要在 Mac 的 Terminal 中完成，Windows 系统可以使用 Git-bash。）这里注意这里的 path 和 username 需要根据你个人情况进行替换。</p><pre><code><div>cd ~/Path git clone https://GitHub.com/username/username.GitHub.io</div></code></pre><figure tabindex="0" draggable="false" class="ss-img-wrapper custom-width" contenteditable="false"><img src="https://cdn.sspai.com/2019/05/09/0ac45ab544aaed52fa54338b9e84f43e.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt width="620" data-original="https://cdn.sspai.com/2019/05/09/0ac45ab544aaed52fa54338b9e84f43e.png"><figcaption class="ss-image-caption"></figcaption></figure><p>接着进入你的项目的文件中，并创作一个文章。</p><pre><code><div>cd username.GitHub.ioecho &#34;Hello World 我爱这个世界&#34; &gt; index.md</div></code></pre><p>然后按照 Git 提交内容的流程，将我们的新创作的文章上传。</p><pre><code><div>git add --allgit commit -m &#34;Firs Push&#34;git push -u origin master</div></code></pre><p>这里可能会碰到下面的情况：</p><figure tabindex="0" draggable="false" class="ss-img-wrapper custom-width" contenteditable="false"><img src="https://cdn.sspai.com/2019/05/09/e2389fe0c465bab0fdc263e96574238f.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt width="620" data-original="https://cdn.sspai.com/2019/05/09/e2389fe0c465bab0fdc263e96574238f.jpg"><figcaption class="ss-image-caption"></figcaption></figure><p>按照他的提示我们把注册 GitHub 的邮箱和用户名依次输入即可：</p><pre><code><div>git config user.email &#34;你的邮箱&#34;git config user.name &#34;你的用户名&#34;</div></code></pre><p>之后他可能会让你输入你的 GitHub 账号和密码，不用担心，正常输入即可。当我们看到这样的提升就证明提交成功了。</p><figure tabindex="0" draggable="false" class="ss-img-wrapper custom-width" contenteditable="false"><img src="https://cdn.sspai.com/2019/05/09/f707deafab9ed1231d20af9ed4185af2.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt width="620" data-original="https://cdn.sspai.com/2019/05/09/f707deafab9ed1231d20af9ed4185af2.jpg"><figcaption class="ss-image-caption"></figcaption></figure><p>可以去我们的网站主页看看是不是起了变化。</p><figure tabindex="0" draggable="false" class="ss-img-wrapper custom-width" contenteditable="false"><img src="https://cdn.sspai.com/20190508161225.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt width="620" data-original="https://cdn.sspai.com/20190508161225.png"><figcaption class="ss-image-caption"></figcaption></figure><p>如果你是使用<a href="https://desktop.GitHub.com/" target="_blank" rel="noopener">GitHub 桌面客户端</a> 那么就更简单了，下载安装了客户端之后，按照客户端的提示正常登陆你的 GitHub 账号。然后 Clone 下来你的 GitHub Pages 项目。</p><figure tabindex="0" draggable="false" class="ss-img-wrapper custom-width" contenteditable="false"><img src="https://cdn.sspai.com/20190508161237.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt width="620" data-original="https://cdn.sspai.com/20190508161237.png"><figcaption class="ss-image-caption"></figcaption></figure><p>等待 Clone 完成后，界面上会显示几种管理修改你的项目的方式。</p><figure tabindex="0" draggable="false" class="ss-img-wrapper custom-width" contenteditable="false"><img src="https://cdn.sspai.com/20190508161341.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt width="620" data-original="https://cdn.sspai.com/20190508161341.png"><figcaption class="ss-image-caption"></figcaption></figure><p>这里我选择使用 Sublime Text 进行管理，把开始的 <a href="http://index.md" target="_blank" rel="noopener">index.md</a> 里的内容改为 <code>Hello World 我也爱这个世界</code> 保存，然后在客户端上我们能看到文件的变化，我们先点击左下角的 Commit to master，再点击 Fetch origin 就可以将内容上传。</p><figure tabindex="0" draggable="false" class="ss-img-wrapper custom-width" contenteditable="false"><img src="https://cdn.sspai.com/20190508161353.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt width="620" data-original="https://cdn.sspai.com/20190508161353.png"><figcaption class="ss-image-caption"></figcaption></figure><p>然后你发现你的主页也发生了相应改变了。到这里你基本上就掌握了网站管理的基本流程和文章发布的基本流程，下面我们要开始来学会使用静态模板系统来管理博客了。</p><h3 id="ss-H3-1557303536767">GitHub Pages 的生成工具</h3><p>经历了上面的步骤，现在你的已经有了一个简单的页面了，可是他还远远未满足我们的需求，我们需要利用静态模板系统来让生产接管你博客的文章的生成，让你把更多的经历投入在创作里。下面就 GitHub 官方推荐的 Jekyll 为例子来展开讲讲。</p><p>因为 Jekyll 是基于 Ruby 的静态网页生成系统，因此我们首先得安装 Ruby 环境，在 Mac 下我们可以使用的 Homebrew 来进行安装。如果是其他操作系统，可以去参考 <a href="https://www.ruby-lang.org/en/documentation/installation/" target="_blank" rel="noopener">Ruby 官方安装文档</a>进行安装。</p><pre><code><div>brew install ruby</div></code></pre><p>等 Ruby 安装完毕后再执行以下命令完成 Jekyll 的安装。</p><pre><code><div>gem install jekyll bundler</div></code></pre><p>然后进入你 Clone 下来的 GitHub Pages 项目的路径，例如：</p><figure tabindex="0" draggable="false" class="ss-img-wrapper custom-width" contenteditable="false"><img src="https://cdn.sspai.com/20190508161408.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt width="620" data-original="https://cdn.sspai.com/20190508161408.png"><figcaption class="ss-image-caption"></figcaption></figure><p>执行以下命令：</p><pre><code><div>jekyll new . --force</div></code></pre><p>完成后，Jekyll 会在你指定的目录下生成好所有文件，你可以使用 <code>bundle exec jekyll serve</code> 命令，然后就可以通过访问 <code>127.0.0.1:4000</code> 查看初始界面的样子了。</p><figure tabindex="0" draggable="false" class="ss-img-wrapper custom-width" contenteditable="false"><img src="https://cdn.sspai.com/20190508161423.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt width="620" data-original="https://cdn.sspai.com/20190508161423.png"><figcaption class="ss-image-caption"></figcaption></figure><p>默认的界面看起来非常的简陋也很丑，但是没关系，你可以在这些网站里根据自己的喜好找到一些美观的主题<a href="http://jekyllthemes.org/" target="_blank" rel="noopener">http://jekyllthemes.org/</a>、<a href="https://jekyllthemes.io/" target="_blank" rel="noopener">https://jekyllthemes.io/</a>、<a href="http://themes.jekyllrc.org/" target="_blank" rel="noopener">http://themes.jekyllrc.org/</a>。</p><p>安装方法很简单，一般情况下只需要下载主题包解压后完整的，复制到你的 GitHub Pages 的项目目录里，并覆盖你之前的文件即可，有些特殊的主题要参考作者给的安装步骤，这里我随意的更换了一个主题。</p><figure tabindex="0" draggable="false" class="ss-img-wrapper custom-width" contenteditable="false"><img src="https://cdn.sspai.com/20190508161453.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt width="620" data-original="https://cdn.sspai.com/20190508161453.png"><figcaption class="ss-image-caption"></figcaption></figure><p>主题里的所有关键性配置都在 _config.yml 文件中，你可以根据个人的喜好和不同主题支持的功能来修改具体的内容，这里就不做展开。</p><p>到这里完整的搭建的流程已经结束了，你已经可以正常访问你一路配置下来的博客了，接下来你只需要找一个趁手的 Markdown 编辑器来编辑在你本地 GitHub Pages 项目中的 _posts 文件夹里的文章，并使用前面提到的两种方式将文章同步到 GitHub 上即可。需要注意的是，文章的内容和标题需要按照 Jekyll 的格式进行写作。</p><p>文章的文件名遵循下面的格式：</p><pre><code><div>年-月-日-标题.markdown</div></code></pre><p>文章内容顶部必须有下面的 YAML 头信息：</p><pre><code><div>---layout: posttitle: Blogging Like a Hacker---</div></code></pre><h2 id="ss-H2-1557303542244">尾巴</h2><p>其实除了 Jekyll 还有非常多的第三方的静态模板系统来搭建 GitHub Pages。比如：</p><ul><li>Node.js 编写的 Hexo</li><li>Go 编写的 Hugo</li><li>Python 编写的 Pelican</li><li>以及更人性化的 Gridea</li></ul><p>他们在各自的基础上实现了更多的功能，比如分析统计、搜索、评论系统、广告、分享系统等。喜欢折腾的同学不妨可以尝试尝试，未来如果有机会希望能更详细的给大家分享一下。</p><p><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Course" scheme="https://eliasliangyu.github.io/tags/Course/"/>
    
  </entry>
  
</feed>
